<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="">
    <meta name="description" content="">
    <title>修改文档</title>
    <link href="css/bootstrap.css" rel="stylesheet" />
    <link href="css/style.css" rel="stylesheet" />
</head>
<body>
<div class="bg-grey PLR40">

    <div class="paper-txt P30 PB0">
        <div class="alert alert-success" role="alert">此为您在“详细报告”中修改后临时保存的内容，编辑过的内容会变绿色</div>
        <p class="text-idt25" data-id="1">第一章绪论</p><p class="text-idt25" data-id="2">1.1 研究背景和意义</p><p class="text-idt25" data-id="3">随着 SOA[21]、 DevOps、持续交付、虚拟化、分布式系统等各种技术的快速出现和发展，软件系统的业务逐渐复杂，开发体量逐渐变大，虽然传统分层的单体架构有易部署，易测试的优点，但是其不足之处越来越明显，随着需求的不断增加，越来越多的人加入开发团队，代码库也在飞速膨胀，进而产生单体应用变得越来越臃肿，可维护性、灵活性逐渐降低，维护成本越来越高等一系列问题，这些问题会给整个云平台的开发、维护、部署以及后期的升级带来巨大的困难，因此单体架构很难满足互联网时代快速变化的需要。</p><p class="text-idt25" data-id="4">针对上述问题的解决方法就是将微服务架构应用到云平台上，对现有的业务系统进行拆分和重组，将原有的系统拆分成独立的模块来降低系统整体的复杂度、代码的冗余率以及各个子系统、功能模块之间的耦合程度，因此微服务架构[1][2]获得广泛的关注。微服务是最近非常流行的系统架构解决方案，其核心思想是将大型的、复杂的应用划分成细粒度且内聚的服务，划分后的服务都有各自的服务边界和声明周期，并且便于部署和扩展，各服务间配合工作完成任务。</p><p class="text-idt25" data-id="5">相对于单体应用架构来说，微服务架构有着易于开发和维护、单个微服务启动较快、局部修改容易部署、技术栈不受限、按需伸缩等优点，但是，微服务并非是完美的，使用微服务也为我们的工作带来了一定的挑战。本文中微服务平台主要有两个问题。</p><p class="text-idt25" data-id="6">问题一，如何实现高效的服务划分[3]，提高微服务平台的服务复用率，降低代码的冗余。微服务的粒度是难点，也常常是争论的焦点。应当使用合理的粒度划分微服务，而不是一味地把服务做小。代码量的多少不能作为微服务划分的依据，因为不同的微服务本身的业务复杂性不同，代码量也不同。在微服务的设计阶段，就应确定其边界。微服务之间应相对独立并保持松耦合[4][5]。目前围绕微服务的划分工作是有限的，在现有技术水平上，微服务缺乏工具支持，很大一部分工作只是概念性的[6]，因此在微服务领域应用服务划分技术需要进一步的研究。如何划分微服务，制定划分策略，满足微服务内部的高内聚性和微服务之间的低耦合性，是我们面临的主要问题。</p><p class="text-idt25" data-id="7">问题二，如何进行服务路径选择，得到最优的服务路径，降低服务的执行时间，提高应用的执行效率。对于基于微服务架构的分布式处理云平台，微服务划分完成，如何组合微服务[7][8]，制定相应的微服务路径选择策略，对于提高应用的执行效率尤其重要，也是目前研究的热点问题。目前大多数的服务选择策略只考虑服务静态特征[9]，例如服务响应程度，服务利用率，吞吐量，并没有考虑服务实例运行时特征。对于由多个子任务组成的大型应用来说，当前一个子任务被执行完成后，后面的子任务对应的微服务实例的资源状态会时刻动态改变，所以初始化最优的服务路径可能是无效的。如何根据微服务的实时处理能力自适应的更新微服务路径[10][11]，以实现高效的应用执行效率。当今一些动态的自适应[12]的算法被提出来，这些方法选择合适的候选服务来创建最优的服务路径，并且根据服务状态的改变，动态的更新服务路径，然而他们并没有考虑任务细粒度的特征，即使是相同的任务，不同的数据，也会导致应用处理效率不同。</p><p class="text-idt25" data-id="8">综上，在微服务平台中，设计合理的服务划分策略，实现高效的应用执行效率，还有许多工作要做。近年来，微服务架构成为了云计算领域的热点话题，微服务已经成为现代大型工程组织中的新兴趋势，然而目前还没有在微服务平台设计合理的微服务方法以及综合考虑平台动态特征和任务特征的服务选择方法的公开案例，本文研究了微服务架构，提出了一种高效的服务划分方法和服务选择策略，有效提高了微服务平台中服务的复用率，降低了服务的执行时间，提高了应用的执行效率。</p><p class="text-idt25" data-id="9">1.2 国内外研究现状</p><p class="text-idt25" data-id="10">微服务架构的概念作为一种新型的软件架构在最近几年来引起了国内外专家的广泛关注。如何划分微服务以及确定微服务的粒度[13]是研究的难点，也是服务计算领域争论的焦点。在微服务的设计阶段，应该确定其边界[4]。Eberhard Wolf在文献[14]中提出微服务的规模应该足够小，并专注于实现一个功能；Mohsen Ahmadvand等人[15]指出微服务分解的时候应该考虑系统要求、安全性和可扩展性，然而这些并不是分解微服务时应该考虑的唯一因素；Tugrul Asik等人[16]提出通过计算用于其他微服务或者外部服务交互的资源和客户的和来衡量一个微服务的大小。由于衡量微服务大小的因素是模糊的，因此将一个应用分解成合适的微服务是一个具有挑战性的工作。目前，在实践中已经提出了许多策略来确定微服务的大小以及如何微服务。 Gerald Schermann等人[17]将微服务的大小与代码行数（ LOC）联系起来，并且建议微服务的规模应该在10到100个 LOC，文中指出计算 LOC是微服务不应该超过的代码的行数，因此微服务的代码行数越少就增加了微服务扩展的灵活性并且简化了更改或者移除微服务的过程。但是LOC策略是不合适的，因为微服务有可能使用不同的技术栈构建的，而这些技术栈在LOC上是不同的。此外，不同的服务类型最小的LOC可能是不同的。 Mario Villamizar等人[18]提出将微服务定义为独立开发和部署的单元，这些微服务的集合可以部署成一个大的应用，这些服务的划分通过注册的方式划分，被其他服务发现并且可以在部署和更新过程中编排。 Ulrich Kalex在文献[19]中通过基于业务能力和业务功能来构建微服务，但是开发人员在使用业务功能作为微服务划分边界时面临着很大挑战，如何定义一个业务能力的的粒度才能使其不会太大或者太小。可见国内外为了得到高效的微服务划分方法，或者通过代码行数来确定微服务边界，或者通过业务能力来确定微服务边界，目前还很少使用语义耦合的方式来划分微服务。本文实现的基于领域驱动设计思想的微服务划分策略，将有效提高服务的复用率。</p><p class="text-idt25" data-id="11">为了提高应用的执行效率，服务选择的方法至关重要，目前国内外已有很多关于服务选择的方法涌现。M. Alrifai等人[7]提出通过考虑服务之间的 QoS相关性来选择合适的候选服务，该方法可以管理服务之间相关性，并显著提高生成的组合服务的 QoS值； Shuiguang Deng等人[8]提出了提出一种基于 skyline的服务选择方法来进行服务组合，该方法通过减少要考虑的候选服务的数量来有效的组合服务，尽管这些方法是为了获得最优的服务组合，但是这些方法并没有考虑服务中资源的运行时状态，不能保证在线任务的处理效率；Tian Huat Tan等人[10]提出一种基于遗传算法的方法来优化服务组合整体的QoS，并进行服务组合的自适应更新；Wang等人[11]提出了一种利用强化学习的方法来保证服务组合的时候的自适应性，该方法通过博弈论来决定服务优化的方向；Peng等人[20]提出一种自适应的方法rEDA来支持动态的QoS感知的服务组合的优化；文献中[17][18]提出云计算平台中性能感知的自适应的服务选择和组合方案，该自适应服务路径选择方法满足了用户的 QoS的同时又保证了整个系统中的负载均衡。尽管这些方法解决了仅仅依据静态 QoS进行服务选择的问题，能够支持在线服务的自适应更新，但是这些方法并没有考虑任务的特征，因此不能将这些方法直接应用到微服务平台上进行服务选择。本文提出的性能感知的服务路径选择策略在进行服务路径选择时充分考虑了微服务实例的实时的处理能力、以及任务的特征和微服务实例间的传输条件，得到了最优的服务路径，提高了应用的执行效率。</p><p class="text-idt25" data-id="12">综上所述，国内外为了解决服务划分问题，或者将代码行数作为边界，或者通过分析平台的业务能力作为边界，目前服务计算领域很少将语义耦合的概念使用到服务划分中；为了解决服务选择问题，国内外的研究很多只考虑服务静态QoS，目前很少研究将机器学习方法与服务选择技术来提高应用执行效率。本文结合平台应用的特点，设计了语义耦合的服务划分方法和性能感知的服务选择方法，减少了服务执行时间，提高了平台的执行效率。</p><p class="text-idt25" data-id="13">1.3 论文的主要研究内容</p><p class="text-idt25" data-id="14">上文提到的微服务平台中遇到的两个难点问题：（1）在进行微服务划分时，如何确定服务的边界，来确定微服务的粒度，制定合理的服务划分方法，提高平台中服务的复用率。（2）如何进行服务路径选择，得到最优的服务路径，降低服务的执行时间，提高应用的执行效率。本文针对以上问题提出了基于领域驱动设计的服务划分方法和性能感知的服务选择策略，主要研究内容有以下几点：</p><p class="text-idt25" data-id="15">（1）基于领域驱动设计的服务划分方法</p><p class="text-idt25" data-id="16">为了解决难点1，本文分析了当前主流的服务划分方法，当前的服务划分要么从代码行数来考虑服务的边界，要么从业务能力来考虑服务的边界，不能很好的来确定服务的粒度。本文提出了一种基于领域驱动设计思想的服务划分方法，该方法首先建立服务划分模型，包括单体架构阶段、图阶段、微服务阶段，通过构建过程和聚合过程两个过程得到最优的微服务集合，并通过实验证明，该方法可以有效的提高平台中服务的复用率，减少应用代码的冗余。</p><p class="text-idt25" data-id="17">（2）性能感知的服务路径选择方法</p><p class="text-idt25" data-id="18">当前主流的服务选择策略，要么是没有考虑在线微服务处理能力，要么就是没有考虑任务的特征。为了解决难点2，本文利用微服务平台的应用程序，分析微服务平台中在线微服务实例的细粒度特征、待执行任务的特征以及微服务实例间的数据传输条件，建立针对微服务平台的细粒度的性能预测模型，基于建立的性能预测模型，提出了性能感知的服务选择策略，通过缩减服务选择空间在线更新微服务选择路径，进一步提高了微服务平台中应用的执行效率。</p><p class="text-idt25" data-id="19">（3）实验验证和性能分析</p><p class="text-idt25" data-id="20">本文在微服务平台上，提出一种基于领域驱动设计模型思想的微服务划分方法，支持原有平台功能的微服务化，提高平台服务的复用率，保证平台持续部署；提出性能感知的微服务路径选择策略，实现平台应用的高效执行。本项目通过实验，对微服务化后的系统中代码规模减少率以及服务复用率来对微服务划分方法进行性能分析，从而证明了本项目中提出的微服务划分方法能够有效划分微服务；本文利用微服务平台的应用，对文中提出的性能感知的服务路径选择策略的性能进行验证，通过对比实验以及对结果分析，从而证明本文提出的服务路径选择策略能够提高平台应用的执行效率。</p><p class="text-idt25" data-id="21">1.4 论文组织结构</p><p class="text-idt25" data-id="22">本论文将按照以下六个章节展开：</p><p class="text-idt25" data-id="23">第一章：绪论。首先介绍了本文的研究背景，然后介绍了目前微服务平台中服务划分策略和服务选择策略的研究现状，最后介绍了本文的主要研究内容。</p><p class="text-idt25" data-id="24">第二章：相关技术。主要介绍了微服务划分策略相关的一些背景知识，包括微服务架构以及软件工程相关技术，另外还有服务选择策略相关的背景知识，包括基于静态的 Qos的服务选择路径以及基于动态的自适应更新的服务选择路径。本章为后续研究和平台开发奠定基础。</p><p class="text-idt25" data-id="25">第三章：基于领域驱动设计思想的语义耦合的服务划分策略。首先对当前的服务划分策略进行了分析，然后结合我们微服务平台的特点设计出适合我们微服务平台的服务划分策略，最后通过算法对比，给出了适合我们微服务平台的服务划分策略。</p><p class="text-idt25" data-id="26">第四章：性能感知的服务路径选择策略研究。这部分是本文的核心。首先对当前的服务选择策略进行分析指出不足之处，然后结合我们微服务平台的特点以及微服务应用的特征设计出性能感知的时间预测模型，然后介绍了基于时间预测模型的初始化路径选择策略，并详细的介绍了该策略的实现过程。最后介绍了微服务路径的动态的更新策略，并详细的介绍了该策略的实现过程。</p><p class="text-idt25" data-id="27">第五章：系统实现与测试分析。首先描述了微服务系统中主要组成部分的详细实现，接着论述了服务划分策略和服务路径选择策略的详细实现，之后介绍了测试环境配置，最后基于视频浓缩算法功能镜像对本文提出的服务路径选择算法的性能、以及提出的性能感知的时间预测模型，以及服务路径选择策略的性能进行实验测试，并对实验结果进行了分析。</p><p class="text-idt25" data-id="28">第六章：结束语。对本文的所有研究工作做出总结，结合目前行业热点展望微服务平台中服务划分和服务选择策略为了的研究趋势，分析本文提出的服务划分和服务选择策略进一步的优化方向。</p><p class="text-idt25" data-id="29">第二章相关技术介绍</p><p class="text-idt25" data-id="30">本章主要介绍了后续章节涉及的一些技术知识，首先详细介绍了单体式软件架构，重点指出该架构的一些重要问题，从而引出今年来兴起的微服务软件架构，阐述该架构的优势。然后介绍了</p><p class="text-idt25" data-id="31">2.1微服务相关技术</p><p class="text-idt25" data-id="32">2.1.1单体式软件架构</p><p class="text-idt25" data-id="33">许多项目都是从单体应用开始的，单体应用比较容易部署、测试，在项目的初期，单体应用可以很好地运行。然而随着需求的不断增加，越来越多的人加入开发团队，代码库也在飞速地膨胀。慢慢地，单体应用变得越来越臃肿，可维护性、灵活性逐渐降低，维护成本越来越高。单体应用存在的主要问题如下：</p><p class="text-idt25" data-id="34">（1）复杂性高：在比较大型的单体应用中，整个项目包含的模块非常多、模块的边界模糊、依赖关系不清晰、代码质量参差不齐、混乱地堆砌在一起……整个项目非常复杂。每次修改代码都心惊胆战，甚至添加一个简单的功能，或者修改一个Bug都会带来隐含的缺陷。</p><p class="text-idt25" data-id="35">（2）技术债务：随着时间推移、需求变更和人员更迭，会逐渐形成应用程序的技术债务，并且越积越多。“不坏不修（Not broken，don’t fix）”，这在软件开发中非常常见，在单体应用中这种思想更甚。已使用的系统设计或代码难以被修改，因为应用程序中的其他模块可能会以意料之外的方式使用它。</p><p class="text-idt25" data-id="36">（3）部署频率低：随着代码的增多，构建和部署的时间也会增加。而在单体应用中，每次功能的变更或缺陷的修复都会导致需要重新部署整个应用。全量部署的方式耗时长、影响范围大、风险高，这使得单体应用项目上线部署的频率较低。而部署频率低又导致两次发布之间会有大量的功能变更和缺陷修复，出错率比较高。</p><p class="text-idt25" data-id="37">（4）可靠性差：某个应用Bug，例如死循环，可能会导致整个应用的崩溃。</p><p class="text-idt25" data-id="38">（5）扩展能力受限：单体应用只能作为一个整体进行扩展，无法根据业务模块的需要进行伸缩。例如，应用中有的模块是计算密集型的，它需要强劲的CPU；有的模块则是IO密集型的，需要更大的内存。由于这些模块部署在一起，不得不在硬件的选择上做出妥协。</p><p class="text-idt25" data-id="39">（6）阻碍技术创新：单体应用往往使用统一的技术平台或方案解决所有的问题，团队中的每个成员都必须使用相同的开发语言和框架，要想引入新框架或新技术平台会非常困难。例如，一个使用Struts 2构建的、有100万行代码的单体应用，如果想要换用Spring MVC，毫无疑问切换的成本是非常高的。综上，随着业务需求的发展，功能的不断增加，单体架构很难满足互联网时代业务快速变化的需要。</p><p class="text-idt25" data-id="40">2.1.2SOA架构</p><p class="text-idt25" data-id="41">上小节介绍了传统的单体式软件架构的不足，早在二十世纪90年代，基于接口/组件的SOA软件架构[21]获得了很不错的发展势头。面向服务的架构（SOA）是一种软件体系结构，应用程序的不同组件通过网络上的通信协议向其他组件提供服务。通信可以是简单的数据传递，也可以是两个或多个服务彼此协调连接，这些独特的服务执行一些小功能。面向服务的架构不太关于如何对应用程序进行模块化构建，更多的是关于如何通过分布式、单独维护和部署的软件组件的集成来组成应用程序。这些通过技术和标准来实现，通过技术和标准使得组件能够更容易地通过网络（尤其是IP网络）进行通信和协作。SOA架构中有两个主要角色：服务提供者（ Provider）和服务使用者（ Consumer），而软件代理则可以扮演这两个角色，该 Consumer层是用户与 SOA交互的点，和 Provider层则由 SOA架构内的所有服务所构成。SOA在90年代中期得名，使得大家认识了这个软件架构的新趋势。该架构相比于单体架构的优点主要有：</p><p class="text-idt25" data-id="42">（1）把模块拆分，使用接口通信，降低模块之间的耦合度。</p><p class="text-idt25" data-id="43">（2）把项目拆分成若干个子项目，不同的团队负责不同的子项目。</p><p class="text-idt25" data-id="44">（3）增加功能时只需要再增加一个子项目，调用其他系统的接口就可以。</p><p class="text-idt25" data-id="45">（4）可以灵活的进行分布式部署。</p><p class="text-idt25" data-id="46">但是SOA架构也有一些问题：</p><p class="text-idt25" data-id="47">（1）系统和服务的界限模糊，不利于开发及维护。</p><p class="text-idt25" data-id="48">（2）虽然使用了ESB，但是服务的接口协议不固定，种类繁多，不利于系统维护。</p><p class="text-idt25" data-id="49">（3）抽取的服务的粒度过大，系统和服务之间耦合性高。</p><p class="text-idt25" data-id="50">因此，SOA更适合需要与许多其他应用程序集成的大型复杂企业应用程序环境。这就是说，小型应用程序不适合 SOA架构，因为它们不需要消息中间件组件，而微服务架构，在另一方面，是更适合于较小和良好的分割，基于 Web的系统。在下一小节中，本文将详细介绍微服务架构。</p><p class="text-idt25" data-id="51">2.1.3 微服务架构</p><p class="text-idt25" data-id="52">上小节介绍了单体应用架构和 SOA软件架构存在的问题，微服务架构模式有助于解决这些问题，当前微服务的概念已经成为软件架构的热门话题之一，微服务架构是一种互联网应用服务的软件架构，主要应用于互联网应用服务的服务端软件开发。微服务架构由面向服务架构 SOA发展而来，其核心理论基础来自于康威定律[19]中关于组织结构与其设计的系统结构之间关系的描述，即任何组织设计的系统，其结构都是组织本身沟通结构的复制。2014年学者 Martin Fowler 正式提出微服务架构的概念[1]:微服务架构风格是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间通信采用轻量级通信机制（通常用 HTTP资源 API）。这些服务围绕业务能力构建并且可通过全自动部署机制独立部署。这些服务共用一个最小型的集中式的管理，服务可用不同的语言开发，使用不同的数据存储技术。它和传统的单体式架构、SOA服务架构的不同如图2-1。</p><p class="text-idt25" data-id="53">图2-1 单体架构、SOA架构和微服务架构</p><p class="text-idt25" data-id="54">微服务架构具备以下特性：</p><p class="text-idt25" data-id="55">（1）易于开发和维护：一个微服务只会关注一个特定的业务功能，所以它业务清晰、代码量较少。开发和维护单个微服务相对简单。而整个应用是由若干个微服务构建而成的，所以整个应用也会被维持在一个可控状态。</p><p class="text-idt25" data-id="56">（2）单个微服务启动较快：单个微服务代码量较少，所以启动会比较快。</p><p class="text-idt25" data-id="57">（3）局部修改容易部署：单体应用只要有修改，就得重新部署整个应用，微服务解决了这样的问题。一般来说，对某个微服务进行修改，只需要重新部署这个服务即可。每个服务为独立的业务开发，一个微服务只关注某个特定的功能。</p><p class="text-idt25" data-id="58">（4）技术栈不受限：在微服务架构中，可以结合项目业务及团队的特点，合理地选择技术栈。例如默写服务可使用关系型数据库MySQL；某些微服务有图形计算的需求，可以使用Neo4j；甚至可根据需要，部分微服务使用Java开发，部分微服务使用Node.js开发。</p><p class="text-idt25" data-id="59">（5）按需伸缩：可根据需求，实现细粒度的扩展。例如，系统中的某个微服务遇到了瓶颈，可以结合这个微服务的业务特点，增加内存、升级CPU或者是增加节点。</p><p class="text-idt25" data-id="60">综上，单体架构和SOA架构的缺点，恰恰是微服务的优点。本文认为微服务架构在构建云服务中具有更明显的优势，这是因为每个微服务可独立运行在自己的进程里，且一系列独立运行的微服务共同构建起整个系统，每个服务为独立的开发业务，一个微服务只关注某个特定的功能，且微服务之间通过一些轻量级的通信机制进行通信。除此之外，由于微服务的轻量级特性使云平台更易于管理、更容易实现负载均衡、减少资源碎片、提高资源利用率。</p><p class="text-idt25" data-id="61">2.2机器学习相关技术</p><p class="text-idt25" data-id="62">机器学习 ( Machine Learning ) 是一门多领域交叉学科，它涉及到概率论、统计学、计算机科学以及软件工程。机器学习是指一套工具或方法，凭借这套工具和方法，利用历史数据对机器进行“训练”进而“学习”到某种模式或规律，并建立预测未来结果的模型。</p><p class="text-idt25" data-id="63">机器学习涉及两类学习方法（如图2-2）：有监督学习，主要用于决策支持，它利用有标识的历史数据进行训练，以实现对新数据的标识的预测。有监督学习方法主要包括分类和回归；无监督学习，主要用于知识发现，它在历史数据中发现隐藏的模式或内在结构。无监督学习方法主要包括聚类。</p><p class="text-idt25" data-id="64">图 2-2 机器学习</p><p class="text-idt25" data-id="65">2.2.1 回归分析技术简介</p><p class="text-idt25" data-id="66">本小节我们主要讲解以下回归分析技术。在统计学中，回归分析（regression analysis)是确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法。运用十分广泛，回归分析按照涉及的变量的多少，分为一元回归和多元回归分析；按照自变量的多少，可分为简单回归分析和多重回归分析；按照自变量和因变量之间的关系类型，可分为线性回归分析和非线性回归分析。如果在回归分析中，只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示，这种回归分析称为一元线性回归分析。如果回归分析中包括两个或两个以上的自变量，且自变量之间存在线性相关，则称为多重线性回归分析。在大数据分析中，回归分析是一种预测性的建模技术，它研究的是因变量（目标）和自变量（预测器）之间的关系。这种技术通常用于预测分析，时间序列模型以及发现变量之间的因果关系。例如，司机的鲁莽驾驶与道路交通事故数量之间的关系，最好的研究方法就是回归。机器学习中的回归问题属于有监督学习的范畴。回归问题的目标是给定 D维输入变量 x，并且每一个输入矢量 x都有对应的值 y，要求对于新来的数据预测它对应的连续的目标值 t。</p><p class="text-idt25" data-id="67">如果要预测的值是连续的，那么就属于回归问题；如果要预测的值是离散的即一个个标签，那么就属于分类问题。这个学习处理过程如图2-2。</p><p class="text-idt25" data-id="68">图2-3的学习过程中的常用术语：输入的数据集称为训练集training set；输入变量x为特征features；输出的预测值y为目标值target；拟合的曲线，一般表示为y = h(x)，称为假设模型hypothesis；训练集的条目数称为特征的维数。</p><p class="text-idt25" data-id="69">图2-3 学习处理过程</p><p class="text-idt25" data-id="70">回归分析方法的特点如下：</p><p class="text-idt25" data-id="71">（1）回归分析法在分析多因素模型时，更加简单和方便；</p><p class="text-idt25" data-id="72">（2）运用回归模型，只要采用的模型和数据相同，通过标准的统计方法可以计算出唯一的结果，但在图和表的形式中，数据之间关系的解释往往因人而异，不同分析者画出的拟合曲线很可能也是不一样的；</p><p class="text-idt25" data-id="73">（3）回归分析可以准确地计量各个因素之间的相关程度与回归拟合程度的高低，提高预测方程式的效果；</p><p class="text-idt25" data-id="74">（4）在回归分析法时，由于实际一个变量仅受单个因素的影响的情况极少，要注意模式的适合范围，所以一元回归分析法适用确实存在一个对因变量影响作用明显高于其他因素的变量是使用。多元回归分析法比较适用于实际经济问题，受多因素综合影响时使用。</p><p class="text-idt25" data-id="75">综上，本文结合回归分析的特点，使用回归分析的方法来训练第四章提到的性能预测模型，通过实验证明，该训练方法可以准确简单的学习得到预测模型。</p><p class="text-idt25" data-id="76">2.2.2线性回归与非线性回归对比</p><p class="text-idt25" data-id="77">回归是一种用于建模和分析变量之间关系的技术，通常是它们如何贡献并且与一起产生特定结果相关。线性回归指的是完全由线性变量组成的回归模型。从简单的情况开始，单变量线性回归是一种用于使用线性模型（即线）来模拟单个输入自变量（特征变量）和输出变量之间的关系的技术。更一般的情况是多变量线性回归，其中为多个独立输入变量（特征变量）和输出因变量之间的关系创建模型。模型保持线性，输出是输入变量的线性组合。按照自变量与因变量之间的函数表达式是线性还是非线性，分为线性回归(Linear Regression)和非线性回归(Non-linear Regression)。我们可以建模多变量线性回归，如公式2-1。</p><p class="text-idt25" data-id="78">Y=</p><p class="text-idt25" data-id="79">a</p><p class="text-idt25" data-id="80">1</p><p class="text-idt25" data-id="81">∗</p><p class="text-idt25" data-id="82">X</p><p class="text-idt25" data-id="83">1</p><p class="text-idt25" data-id="84">+</p><p class="text-idt25" data-id="85">a</p><p class="text-idt25" data-id="86">2</p><p class="text-idt25" data-id="87">∗</p><p class="text-idt25" data-id="88">X</p><p class="text-idt25" data-id="89">2</p><p class="text-idt25" data-id="90">+⋯+</p><p class="text-idt25" data-id="91">a</p><p class="text-idt25" data-id="92">n</p><p class="text-idt25" data-id="93">∗</p><p class="text-idt25" data-id="94">X</p><p class="text-idt25" data-id="95">n</p><p class="text-idt25" data-id="96">+b (2-1)</p><p class="text-idt25" data-id="97">其中</p><p class="text-idt25" data-id="98">a</p><p class="text-idt25" data-id="99">n</p><p class="text-idt25" data-id="100">是系数，</p><p class="text-idt25" data-id="101">X</p><p class="text-idt25" data-id="102">n</p><p class="text-idt25" data-id="103">是变量，b是偏差。可以看到此函数不包含任何非线性，因此仅适用于对线性可分离数据进行建模。线性回归的特点主要有：</p><p class="text-idt25" data-id="104">（1）建模快速简便，当要建模的关系不是非常复杂且没有大量数据时尤其有用。</p><p class="text-idt25" data-id="105">（2）非常直观地理解和解释</p><p class="text-idt25" data-id="106">（3）线性回归对异常值非常敏感。</p><p class="text-idt25" data-id="107">自变量与因变量之间的函数表达式的非线性体现在至少有一个变量的指数不是1即（幂函数，指数函数，对数函数，S函数等形式）。在用非线性回归分析问题时，通常将非线性回归方程式变换为线性回归方程式，求出参数后，再用逆变换将线性回归方程化为非线性回归方程。在化非线性回归为线性回归时，主要是要确定诸变量之间存在的非线性关系的类型。其方法可根据专业知识的理论推导及直接生产或试验数据，从点子分布的特点来选取适当的曲线类型。根据线性回归和非线性回归的特点，本文选择线性回归来建立第四章中的性能预测模型，实验证明我们的性能预测模型能够准确的预测服务的执行时间。</p><p class="text-idt25" data-id="108">2.3最短路径算法</p><p class="text-idt25" data-id="109">2.3.1迪杰斯特算法</p><p class="text-idt25" data-id="110">迪杰斯特拉算法是从一个顶点到其余各顶点的最短路径算法，解决的是有向图中最短路径问题。迪杰斯特拉算法主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。该算法的主要思想如下：</p><p class="text-idt25" data-id="111">按路径长度递增次序产生算法：</p><p class="text-idt25" data-id="112">把顶点集合V分成两组：</p><p class="text-idt25" data-id="113">（1）S：已求出的顶点的集合（初始时只含有源点V0）</p><p class="text-idt25" data-id="114">（2）V-S=T：尚未确定的顶点集合</p><p class="text-idt25" data-id="115">将T中顶点按递增的次序加入到S中，保证：</p><p class="text-idt25" data-id="116">（1）从源点V0到S中其他各顶点的长度都不大于从V0到T中任何顶点的最短路径长度</p><p class="text-idt25" data-id="117">（2）每个顶点对应一个距离值</p><p class="text-idt25" data-id="118">S中顶点：从V0到此顶点的长度</p><p class="text-idt25" data-id="119">T中顶点：从V0到此顶点的只包括S中顶点作中间顶点的最短路径长度</p><p class="text-idt25" data-id="120">依据：可以证明V0到T中顶点Vk的，或是从V0到Vk的直接路径的权值；或是从V0经S中顶点到Vk的路径权值之和。</p><p class="text-idt25" data-id="121">2.3.2维特比算法</p><p class="text-idt25" data-id="122">维特比算法是一个特殊但应用最广的动态规划算法，它是针对篱笆网络的有向图（Lattice）的最短路径问题而提出的。篱笆网络如图2-4。篱笆网络有向图的特点是同一列节点有多个，并且和上一列节点交错地连接起来，同一列节点代表同一个时间点上不同的状态的并列。</p><p class="text-idt25" data-id="123">维特比算法的思想如下：</p><p class="text-idt25" data-id="124">（1）从点 S出发，对于第一个状态 X1的各个节点，不妨假定有 n1个，计算出 S到它们的距离 d( S， X1 i)，其中 X1 i代表任意状态1的节点。因为只有一步，所以这些距离都是S到它们各自的最短距离。</p><p class="text-idt25" data-id="125">（2）对于第二个状态X2的所有节点，要计算出从S到它们的最短距离。对于特点的节点 X2 i，从 S到它的路径可以经过状态1的 n1中任何一个节点 X1 i，对应的路径长度就是 d( S， X2 i)= d( S， X1 i)+ d( X1 i， X2 i)。由于j有n1种可能性，我们要一一计算，找出最小值。即：</p><p class="text-idt25" data-id="126">这样对于第二个状态的每个节点，需要n1次乘法计算。假定这个状态有n2个节</p><p class="text-idt25" data-id="127">点，把S这些节点的距离都算一遍，就有O(n1 n2)次计算。</p><p class="text-idt25" data-id="128">（3）接下来，类似地按照上述方法从第二个状态走到第三个状态，一直走到最后一个状态，就得到了整个网格从头到尾的最短路径。每一步计算的复杂度都和相邻两个状态Si和Si+1各自的节点数目ni，ni+1的乘积成正比，即O(ni ni+1)</p><p class="text-idt25" data-id="129">（4）假设这个隐含马尔可夫链中节点最多的状态有 D个节点，也就是说整个网格的宽度为 D，那么任何一步的复杂度不超过 O( D2)，由于网格长度是 N，所以整个维特比算法的复杂度是 O( N D2)。</p><p class="text-idt25" data-id="130">图 2-4 篱笆网络</p><p class="text-idt25" data-id="131">分析以上的算法的特点，维特比的主要思想就是知道到第i列所有节点</p><p class="text-idt25" data-id="132">X</p><p class="text-idt25" data-id="133">i</p><p class="text-idt25" data-id="134">的最短路径，那么到第 i+1列的最短路径就等于第 i列 j个节点的最短路径+第 i列 j个节点到第 i+1列各个节点距离的最小值。</p><p class="text-idt25" data-id="135">迪杰斯特拉算法是贪心算法，只能得到局部最优的结果，最后结果不一定是全局最优的结果，而维特比算法是动态规划算法，每一步都是全局最优解，最后的结果为全局最优的。由于本文第四章中的到的有向加权图即为篱笆图，要求的结果为篱笆图中全局的最优路径，因此采用维特比算法。</p><p class="text-idt25" data-id="136">2.4 本章小结</p><p class="text-idt25" data-id="137">本章首先介绍了微服务相关技术，包括单体式架构、 SOA架构以及微服务框架相关技术，然后介绍了机器学习相关技术，包括回归分析技术以及线性回归非线性回归的对比，最后介绍了本章用到的最短路径技术，包括迪杰斯特拉算法和维特比算法。本章节主要为后续章节的研究提供基础。</p><p class="text-idt25" data-id="138">语义耦合的微服务划分策略</p><p class="text-idt25" data-id="139">本文主要介绍了基于领域驱动设计思想的语义耦合的微服务划分策略的设计和实现过程。首先总结了当前国内外一些微服务划分方法并且提出了一些不足之处，然后根据平台中应用的特点，微服务高内聚低耦合的划分原则以及软件工程中领域驱动设计的建模思想，提出一种语义耦合的服务划分策略，提高了服务的复用率，减少了应用的代码冗余。</p><p class="text-idt25" data-id="140">3.1当前的服务划分方法概述</p><p class="text-idt25" data-id="141">目前在服务计算领域，已经有一些研究人员对微服务划分进行了相关研究，当前微服务领域主要的挑战是确定微服务的大小以及如何划分微服务[13]。下面是本文总结的主要的服务划分策略：</p><p class="text-idt25" data-id="142">（1）代码行数。一些研究人员将微服务的大小与代码行数（LOC）相关，并且推荐一个服务的代码行数应该在10行到100行代码之间。微服务少的代码行数增加了微服务扩展的灵活性，更易于更改或移除微服务。Gerald Schermann[14]等人通过研究42家不同规模的公司的服务计算实践来研究服务计算领域中的工业实践，并特别关注微服务的趋势。重点研究了服务的大小和复杂性，结果显示不同的服务代码行数是不同的，对于使用代码行数（LOC）来作为划分微服务的标准。但是该策略并不合适，因为微服务是使用不同的技术堆栈构建的，这些技术堆栈在实现功能时，对应的LOC可能有所不同。此外，根据服务的类型，服务也有不同最低LOC。</p><p class="text-idt25" data-id="143">（2）部署单元。该思想中微服务被定义为一种开发和部署的单元，主要是在云环境中部署大型或者中型的应用，且这些服务可以独立的开发、测试、部署、扩展、操作、升级。这些服务根据注册的方式来划分，在部署和升级的过程中，能被其他服务发现并且可以被编排。但是该方法得到的微服务的粒度有可能会很大或者很小。</p><p class="text-idt25" data-id="144">（3）业务能力。业务能力定义为系统在执行唯一的业务时所执行的操作。构建微服务是根据是否一次能解决业务需求或者实现一个业务功能。然而，开发人员在使用业务功能作为微服务的边界时面临着挑战，定义业务能力应该适合的粒度级别，以便它不会太小或太大。</p><p class="text-idt25" data-id="145">综上，以上服务划分策略存在许多问题或者挑战，不能得到高效的服务划分策略，另外当前的服务划分方法中并没有根据平台需求以及平台中应用之间功能的相关性来综合考虑，这将导致服务划分后的结果是服务之间的耦合性比较差，代码复用率比较低，平台中代码的冗余度比较高。</p><p class="text-idt25" data-id="146">3.2解决方案</p><p class="text-idt25" data-id="147">为了实现低耦合高内聚的微服务划分，提高应用中代码的复用率，降低平台中代码的冗余，在进行微服务划分时，我们遵循微服务低耦合高内聚的划分原则，并且考虑到平台中应用之间的功能相关性比较强，两个应用中服务的复用率比较高，因此，我们基于软件设计中领域驱动设计思想，提出了语义耦合的服务划分策略（ DSCS），源自软件工程中领域驱动设计的有界上下文的概念被提出作为微服务及其边界的一种设计思想，根据该思想，每个微服务应该对应于问题域中唯一的一个有界上下文。这将保证了集中于一个职责的微服务的可扩展性和可维护性。因此从软件设计领域提出划分策略，通过信息检索技术检查源代码文件的内容和语义成为一种划分方法，其中我们利用 tf- idf方法分析原有系统中文件代码之间语义之间的相关性，得到系统中每个文件的之间的耦合度，构建无向加权网络图，之后利用具有“低耦合高内聚规则”的社区划分算法-- GN算法，对构建的无向加权图进行划分，得到符合服务划分原则的最优的划分结果。通过实验验证了该方法可以将应用有效划分成微服务，并且能够提高服务的复用率，减少平台的代码冗余。</p><p class="text-idt25" data-id="148">3.3基于语义耦合策略的服务划分模型</p><p class="text-idt25" data-id="149">本节语义耦合的服务划分模型是结合软件工程中领域驱动设计思想以及语义相似性来构建的。</p><p class="text-idt25" data-id="150">3.3.1领域驱动设计思想</p><p class="text-idt25" data-id="151">在软件工程中有一中建模思想领域驱动设计（ DDD）[22]，领域驱动设计的主要思想是将业务领域中的概念与软件元素对应于软件设计中，组成领域驱动的理论和技术其实早已存在，它实现的基础是面向对象的编程方法( Object Oriented Programming， OOP)[23][24]，领域驱动中的实体跟 OOP中的对象相对应， OOP的继承、封装和多态等特征都适用于领域驱动的开发，领域对象应可以设计成简单的类或接口。该思想中主要有三个主要的概念。</p><p class="text-idt25" data-id="152">（1）领域，领域与具体开发技术无关，就是你软件系统要解决的实际问题相关的所有东西的集合。</p><p class="text-idt25" data-id="153">（2）子域。子域是领域更细粒度的划分，根据功能和重要程度主要分为核心子域、支撑子域、通用子域。核心域是业务成功的关键，支撑子域是支持核心域的，通用子域是业务系统的公用部分。</p><p class="text-idt25" data-id="154">（3）限界上下文。限界上下文包含的是一个系统、一个应用、一种业务服务以及一系列实现业务的复杂组件。通用语言是限界上下文中的每种领域术语、词组。通用语言不是一时促成的，而是各方的人员在讨论中提炼出来的。领域模型是把通用语言表达成软件模型。</p><p class="text-idt25" data-id="155">3.3.2 语义相似度技术</p><p class="text-idt25" data-id="156">本文中提出的服务划分方法使用了语义耦合的划分方法，主要使用语义相似度来表明两个文件之间的关系。相似性是存在于任意两个对象之间的一种普遍关系，而相似度是对相似性的定量表示。相似度计算是信息检索、数据挖掘、知识管理、人工智能等领域的基本问题。随着本体的广泛应用，基于本体语义的相似度计算及应用成为心理学和计算机科学交叉研究的一个重要课题。</p><p class="text-idt25" data-id="157"> Dekang提出了一组具有广泛意义的相似度定义告诉我们，对象和对象之间的相似度与它们之间共性和差别相关，两个对象所拥有的共性越多，则相似度越大，而两个对象之间的差异越多，则相似度越小。当两个对象是同一个对象时，相似度是最大的。当两个对象不相关时，相似度最小。</p><p class="text-idt25" data-id="158">相似度模型总的概括分为几何模型和特征对比模型[30][31]。用空间中的点表示对象，用点之间的距离反映对象间的相似度，将这一类模型统称为几何模型。特征对比模型通过特征属性集合描述对象，相似度被定义为关于特征共同性和差异性的函数。</p><p class="text-idt25" data-id="159">本文分析对象的相似度使用的是几何模型，能够清晰简单的表示出两个对象相似度。语义相似度的计算步骤是：1. 特征提取与特征选择。一般情况下，我们使用的对象是用自然语言来描述的，这样的话就只能间接被计算机处理。对象的特征提取指提取出对象的主要特征来表示对象。现有特征描述是根据统计方法构建相应的数学模型来表示对象，目的是从所表示的对象中提取出最有价值的特征信息。但是还会可能遇到特征项的维数问题，因此需要通过特征选择进行特征项的筛选。特征选取需要根据某个准则选择出最能反映对象特性的相关特征，从而达到降低特征维数、简化计算、提高相似度计算准确度的目的。2. 对象的表示。通常，用至少两个特征来描述一个对象，用间隔尺度来量化特征，间隔尺度是使用实数来表示的数量信息。假如选择了个特征，那么这个对象就可以表示成一个向量。3.相似度具体计算方法。设T和T`为矩阵中的两个对象的特征向量，常用相似度公式如下：内积、Dice系数、余弦函数、Jaccard系数等。本文使用余弦函数来计算两个对象的相似度。</p><p class="text-idt25" data-id="160">3.3.3 服务划分模型</p><p class="text-idt25" data-id="161">为了实现微服务的划分，使平台中应用中的服务复用率有效提高且降低平台中代码的冗余，我们基于领域驱动设计思想，设计了服务划分模型，该模型主要有三个阶段组成：第一个阶段单体阶段，第二个阶段图阶段，第三个阶段微服务阶段。在每两个阶段之间包括一次转换，共涉及两次转换，第一次转换是从单体阶段到图阶段的转换，称为构建图过程，第二次转换是从图阶段到微服务阶段的转换，称为聚类过程。下面是我们构建图过程的详细步骤：</p><p class="text-idt25" data-id="162">原有平台中的应用处于单体阶段，从单体阶段到图阶段我们称为构建图阶段，此过程如图3-1：</p><p class="text-idt25" data-id="163">图3-1构建图阶段</p><p class="text-idt25" data-id="164">构建图过程中图𝐺</p><p class="text-idt25" data-id="165">𝐸，𝑉</p><p class="text-idt25" data-id="166">为加权无向图，图中每个顶点</p><p class="text-idt25" data-id="167">𝑣</p><p class="text-idt25" data-id="168">𝑖</p><p class="text-idt25" data-id="169">∈𝑉，对应于单体阶段中的每一个代码文件</p><p class="text-idt25" data-id="170">𝑐</p><p class="text-idt25" data-id="171">𝑖</p><p class="text-idt25" data-id="172">∈𝐶。每一个边</p><p class="text-idt25" data-id="173">𝑒</p><p class="text-idt25" data-id="174">𝑘</p><p class="text-idt25" data-id="175">∈𝐸有一个权重w，并且通过定义的权重公式得到。权重的大小代表了两个文件之间的耦合程度，顶点</p><p class="text-idt25" data-id="176">𝑣</p><p class="text-idt25" data-id="177">𝑖</p><p class="text-idt25" data-id="178">与顶点</p><p class="text-idt25" data-id="179">𝑣</p><p class="text-idt25" data-id="180">𝑗</p><p class="text-idt25" data-id="181">之间的权重</p><p class="text-idt25" data-id="182">𝑤</p><p class="text-idt25" data-id="183">𝑖，𝑗</p><p class="text-idt25" data-id="184">值越大，表示文件</p><p class="text-idt25" data-id="185">𝑐</p><p class="text-idt25" data-id="186">𝑖</p><p class="text-idt25" data-id="187">与文件</p><p class="text-idt25" data-id="188">𝑐</p><p class="text-idt25" data-id="189">𝑗</p><p class="text-idt25" data-id="190">之间的耦合程度越高。</p><p class="text-idt25" data-id="191">因为每个代码文件中都有标识符（变量名，方法名）来表示该文件具有的功能。因此我们可以从每个代码文件中抽取方法名来表示该文件。语义耦合策略就是使用表示该文件的标识符作为 tf- idf的输入，计算出一个表示该文件的向量 X，之后再通过计算两个向量的余弦相似性来表示两个文件之间的耦合程度。</p><p class="text-idt25" data-id="192">建立无向加权图后，现在处于图阶段，由图阶段到微服务阶段，我们称为聚类阶段如图3-2：</p><p class="text-idt25" data-id="193">图3-2聚类阶段</p><p class="text-idt25" data-id="194">聚类过程即将文件之间的耦合图，转换成相应的微服务。在聚类过程中，我们使用经典的社区发现算法 GN算法来实现微服务的划分， GN算法基本思想是不断的删除图中具有相对于所有源节点的最大的边介数的边，然后，再重新计算图中剩余的边的相对于所有源节点的边介数，重复这个过程，直到图中所有边都被删除，使用模块性 Q来衡量划分质量，当模块性 Q函数最大时表示图中服务划分的最好，每个服务之间都保证了“高内聚，低耦合”原则。</p><p class="text-idt25" data-id="195">在本文中，我们使用如下公式定义Q函数：</p><p class="text-idt25" data-id="196">Q=</p><p class="text-idt25" data-id="197">1</p><p class="text-idt25" data-id="198">2𝑀</p><p class="text-idt25" data-id="199">𝑗</p><p class="text-idt25" data-id="200">𝑎</p><p class="text-idt25" data-id="201">𝑖𝑗</p><p class="text-idt25" data-id="202">−</p><p class="text-idt25" data-id="203">𝑘</p><p class="text-idt25" data-id="204">𝑖</p><p class="text-idt25" data-id="205">𝑘</p><p class="text-idt25" data-id="206">𝑗</p><p class="text-idt25" data-id="207">2𝑀</p><p class="text-idt25" data-id="208">𝛿</p><p class="text-idt25" data-id="209">𝜎</p><p class="text-idt25" data-id="210">𝑖</p><p class="text-idt25" data-id="211">，</p><p class="text-idt25" data-id="212">𝜎</p><p class="text-idt25" data-id="213">𝑗</p><p class="text-idt25" data-id="214">(3-6)</p><p class="text-idt25" data-id="215">公式中，</p><p class="text-idt25" data-id="216">𝑎</p><p class="text-idt25" data-id="217">𝑖𝑗</p><p class="text-idt25" data-id="218">为图的邻接矩阵的元素，如果i和j两节点相连，则</p><p class="text-idt25" data-id="219">𝑎</p><p class="text-idt25" data-id="220">𝑖𝑗</p><p class="text-idt25" data-id="221">为边的权重，否则等于0，δ为隶属函数，当节点i和j属于同一微服务时，隶属函数为1，否则为0；M=0.5，</p><p class="text-idt25" data-id="222">𝑎</p><p class="text-idt25" data-id="223">𝑖𝑗</p><p class="text-idt25" data-id="224">为加权无向图中边的权重之和。</p><p class="text-idt25" data-id="225">𝑘</p><p class="text-idt25" data-id="226">𝑖</p><p class="text-idt25" data-id="227">为节点的点权，对联通矩阵的第i行求和。</p><p class="text-idt25" data-id="228">在该算法中最关键的是计算图中的边介数，本文中使用最短路径边介数方法来度量边介数，具体是指从某源节点 S出发通过该边的最短路径的数目，对所有可能的源节点，重复做同样的计算，并将得到的相对于各个不同的源节点的边介数相加，所得的累加和为该边相对于所有源节点的边介数。</p><p class="text-idt25" data-id="229">综上，可以看出该服务划分模型通过两步可以得到最优的服务划分组合，且该服务划分组合符合微服务的“高内聚低耦合”原则。</p><p class="text-idt25" data-id="230">3.3微服务划分策略</p><p class="text-idt25" data-id="231">上一小节详细讲述了微服务划分模型，本小节主要讲述服务划分模型中使用的划分策略——语义耦合策略。</p><p class="text-idt25" data-id="232">3.3.1语义耦合策略</p><p class="text-idt25" data-id="233">基于上节的服务划分模型，如何得到代码库中每个文件之间的关系，本文使用最直接的方式——语义耦合，通过分析两个文件之间的语义相似性，来量化两个文件之间的耦合程度，从而得到整个应用中全部文件之间的关系图——无向加权图。</p><p class="text-idt25" data-id="234">在语义耦合策略中，我们将原有单体式应用中的文件作为输入，将生成的单体式应用中文件之间的关系图作为输出。根据第一小节中语义相似度的计算步骤，首先，本文提取单体式应用中每个文件的特征，在提取特征的过程中，我们选择每个文件中的关键字，例如变量名或者方法名来作为每个文件的特征值，因此任意一个代码文件使用一组具有功能代表的词组</p><p class="text-idt25" data-id="235">𝑊</p><p class="text-idt25" data-id="236">𝑗</p><p class="text-idt25" data-id="237">=</p><p class="text-idt25" data-id="238">𝑤</p><p class="text-idt25" data-id="239">1</p><p class="text-idt25" data-id="240">，</p><p class="text-idt25" data-id="241">𝑤</p><p class="text-idt25" data-id="242">2</p><p class="text-idt25" data-id="243">，…，</p><p class="text-idt25" data-id="244">𝑤</p><p class="text-idt25" data-id="245">𝑛</p><p class="text-idt25" data-id="246">来表示。但是考虑到代表每个文件的词组的维数可能是不同的，我们做了维数的转换过程，我们建立两个代码文件</p><p class="text-idt25" data-id="247">𝑐</p><p class="text-idt25" data-id="248">𝑖</p><p class="text-idt25" data-id="249">的词组</p><p class="text-idt25" data-id="250">𝑊</p><p class="text-idt25" data-id="251">𝑖</p><p class="text-idt25" data-id="252">以及代表代码文件</p><p class="text-idt25" data-id="253">𝑐</p><p class="text-idt25" data-id="254">𝑗</p><p class="text-idt25" data-id="255">的词组</p><p class="text-idt25" data-id="256">𝑊</p><p class="text-idt25" data-id="257">𝑗</p><p class="text-idt25" data-id="258">的并集列表T，</p><p class="text-idt25" data-id="259">𝑇=</p><p class="text-idt25" data-id="260">𝑊</p><p class="text-idt25" data-id="261">𝑖</p><p class="text-idt25" data-id="262">∪</p><p class="text-idt25" data-id="263">𝑊</p><p class="text-idt25" data-id="264">j</p><p class="text-idt25" data-id="265">=</p><p class="text-idt25" data-id="266">𝑡</p><p class="text-idt25" data-id="267">1</p><p class="text-idt25" data-id="268">，</p><p class="text-idt25" data-id="269">𝑡</p><p class="text-idt25" data-id="270">2</p><p class="text-idt25" data-id="271">，…，</p><p class="text-idt25" data-id="272">𝑡</p><p class="text-idt25" data-id="273">𝑘</p><p class="text-idt25" data-id="274">(3-1)</p><p class="text-idt25" data-id="275">接下来是计算代表每个代码文件</p><p class="text-idt25" data-id="276">𝑐</p><p class="text-idt25" data-id="277">𝑖</p><p class="text-idt25" data-id="278">的向量 X，向量 X的维度是词组列表𝑇的长度，向量的第 k个元素的是词组列表 T中第 k个元素在代码文件词组中的 tf- idf值表示。tf-idf值代表该第k个元素即第k个词组在整个并集列表T中的重要程度。向量𝑋中的元素</p><p class="text-idt25" data-id="279">𝑥</p><p class="text-idt25" data-id="280">𝑘</p><p class="text-idt25" data-id="281">计算公式如下：</p><p class="text-idt25" data-id="282">𝑥</p><p class="text-idt25" data-id="283">𝑘</p><p class="text-idt25" data-id="284">=𝑡𝑓</p><p class="text-idt25" data-id="285">𝑡</p><p class="text-idt25" data-id="286">𝑘</p><p class="text-idt25" data-id="287">，</p><p class="text-idt25" data-id="288">𝑊</p><p class="text-idt25" data-id="289">𝑖</p><p class="text-idt25" data-id="290">∗𝑖𝑑𝑓</p><p class="text-idt25" data-id="291">𝑡</p><p class="text-idt25" data-id="292">𝑘</p><p class="text-idt25" data-id="293">，</p><p class="text-idt25" data-id="294">𝑊</p><p class="text-idt25" data-id="295">𝑎𝑙𝑙</p><p class="text-idt25" data-id="296">(3-2)</p><p class="text-idt25" data-id="297">用同样的方法得到向量V中的元素，</p><p class="text-idt25" data-id="298">𝑊</p><p class="text-idt25" data-id="299">𝑎𝑙𝑙</p><p class="text-idt25" data-id="300">表示两个词组的并集即：</p><p class="text-idt25" data-id="301">𝑊</p><p class="text-idt25" data-id="302">𝑎𝑙𝑙</p><p class="text-idt25" data-id="303">=</p><p class="text-idt25" data-id="304">𝑊</p><p class="text-idt25" data-id="305">𝑖</p><p class="text-idt25" data-id="306">，</p><p class="text-idt25" data-id="307">𝑊</p><p class="text-idt25" data-id="308">𝑗</p><p class="text-idt25" data-id="309">(3-3)</p><p class="text-idt25" data-id="310">词频𝑡𝑓</p><p class="text-idt25" data-id="311">𝑡</p><p class="text-idt25" data-id="312">𝑘</p><p class="text-idt25" data-id="313">，</p><p class="text-idt25" data-id="314">𝑊</p><p class="text-idt25" data-id="315">𝑖</p><p class="text-idt25" data-id="316">表示</p><p class="text-idt25" data-id="317">𝑡</p><p class="text-idt25" data-id="318">𝑘</p><p class="text-idt25" data-id="319">在</p><p class="text-idt25" data-id="320">𝑊</p><p class="text-idt25" data-id="321">𝑖</p><p class="text-idt25" data-id="322">中出现的频率的计算公式如下：</p><p class="text-idt25" data-id="323">𝑡𝑓</p><p class="text-idt25" data-id="324">𝑡</p><p class="text-idt25" data-id="325">𝑘</p><p class="text-idt25" data-id="326">，</p><p class="text-idt25" data-id="327">𝑊</p><p class="text-idt25" data-id="328">𝑖</p><p class="text-idt25" data-id="329">=</p><p class="text-idt25" data-id="330">𝑛</p><p class="text-idt25" data-id="331">𝑘，𝑖</p><p class="text-idt25" data-id="332">𝑗</p><p class="text-idt25" data-id="333">𝑛</p><p class="text-idt25" data-id="334">𝑗，𝑖</p><p class="text-idt25" data-id="335">(3-4)</p><p class="text-idt25" data-id="336">其中</p><p class="text-idt25" data-id="337">𝑛</p><p class="text-idt25" data-id="338">𝑘，𝑖</p><p class="text-idt25" data-id="339">表示</p><p class="text-idt25" data-id="340">𝑡</p><p class="text-idt25" data-id="341">𝑘</p><p class="text-idt25" data-id="342">在</p><p class="text-idt25" data-id="343">𝑊</p><p class="text-idt25" data-id="344">𝑖</p><p class="text-idt25" data-id="345">中出现的次数，</p><p class="text-idt25" data-id="346">𝑗</p><p class="text-idt25" data-id="347">𝑛</p><p class="text-idt25" data-id="348">𝑗，𝑖</p><p class="text-idt25" data-id="349">表示所有元素在</p><p class="text-idt25" data-id="350">𝑊</p><p class="text-idt25" data-id="351">𝑖</p><p class="text-idt25" data-id="352">中出现的次数之和。</p><p class="text-idt25" data-id="353">逆向文件频率𝑖𝑑𝑓</p><p class="text-idt25" data-id="354">𝑡</p><p class="text-idt25" data-id="355">𝑘</p><p class="text-idt25" data-id="356">，</p><p class="text-idt25" data-id="357">𝑊</p><p class="text-idt25" data-id="358">𝑖</p><p class="text-idt25" data-id="359">表示一个词语普遍重要性的度量。某一特定词语的idf，可以由文件总数目除以包含该词语文件的数目，再将得到的商取以10为底的对数得到：</p><p class="text-idt25" data-id="360">𝑖𝑑𝑓</p><p class="text-idt25" data-id="361">𝑡</p><p class="text-idt25" data-id="362">𝑘</p><p class="text-idt25" data-id="363">，</p><p class="text-idt25" data-id="364">𝑊</p><p class="text-idt25" data-id="365">𝑎𝑙𝑙</p><p class="text-idt25" data-id="366">=</p><p class="text-idt25" data-id="367">log</p><p class="text-idt25" data-id="368">𝑊</p><p class="text-idt25" data-id="369">𝑎𝑙𝑙</p><p class="text-idt25" data-id="370">𝑛</p><p class="text-idt25" data-id="371">𝑡</p><p class="text-idt25" data-id="372">𝑘</p><p class="text-idt25" data-id="373">(3-5)</p><p class="text-idt25" data-id="374">𝑊</p><p class="text-idt25" data-id="375">𝑎𝑙𝑙</p><p class="text-idt25" data-id="376">=</p><p class="text-idt25" data-id="377">𝑊</p><p class="text-idt25" data-id="378">𝑖</p><p class="text-idt25" data-id="379">，</p><p class="text-idt25" data-id="380">𝑊</p><p class="text-idt25" data-id="381">𝑗</p><p class="text-idt25" data-id="382">表示两个词组集合的集合，n</p><p class="text-idt25" data-id="383">𝑡</p><p class="text-idt25" data-id="384">𝑘</p><p class="text-idt25" data-id="385">表示包含词组</p><p class="text-idt25" data-id="386">𝑡</p><p class="text-idt25" data-id="387">𝑘</p><p class="text-idt25" data-id="388">的文件数目。</p><p class="text-idt25" data-id="389">根据以上方法可以计算出向量X，V中的每一个元素，通过求的两个向量的余弦值来表示两个代码文件之间语义耦合的程度。根据以上方法计算出所有代码文件之间的耦合程度作为建立的图中边的权重，如果耦合度值为0则表示两个定点之间没有连线，那么我们可以建立起相应的无向加权图，我们使用邻接矩阵 A来表示建立的无向加权图，邻接矩阵中的元素表示对应两个节点之间的权重，矩阵如公式3-6：</p><p class="text-idt25" data-id="390">A=</p><p class="text-idt25" data-id="391">𝑎</p><p class="text-idt25" data-id="392">1，1</p><p class="text-idt25" data-id="393">…</p><p class="text-idt25" data-id="394">𝑎</p><p class="text-idt25" data-id="395">1，𝑛</p><p class="text-idt25" data-id="396">⋮</p><p class="text-idt25" data-id="397">⋱</p><p class="text-idt25" data-id="398">⋮</p><p class="text-idt25" data-id="399">𝑎</p><p class="text-idt25" data-id="400">𝑛，1</p><p class="text-idt25" data-id="401">…</p><p class="text-idt25" data-id="402">𝑎</p><p class="text-idt25" data-id="403">𝑛，𝑛</p><p class="text-idt25" data-id="404">(3-6)</p><p class="text-idt25" data-id="405">其中</p><p class="text-idt25" data-id="406">𝑎</p><p class="text-idt25" data-id="407">𝑖，𝑗</p><p class="text-idt25" data-id="408">表示节点</p><p class="text-idt25" data-id="409">𝑣</p><p class="text-idt25" data-id="410">𝑖</p><p class="text-idt25" data-id="411">和节点</p><p class="text-idt25" data-id="412">𝑣</p><p class="text-idt25" data-id="413">𝑗</p><p class="text-idt25" data-id="414">之间的边的权重。</p><p class="text-idt25" data-id="415">综上，我们可以通过语义耦合策略来得到单体式应用中代码之间的耦合关系图——无向加权图 G，并且通过使用矩阵 A来表示无向加权图。</p><p class="text-idt25" data-id="416">3.3.2 服务划分算法</p><p class="text-idt25" data-id="417">上小节中我们得到了单体式应用中代码之间耦合关系图——无向加权图 G，第一阶段完成，进入第二阶段——聚合阶段，聚合阶段的服务划分算法应满足以下要求：</p><p class="text-idt25" data-id="418">（1）可复用性。服务划分算法应满足得到的微服务集合具有高可复用性，这是我们算法的主要目标之一。</p><p class="text-idt25" data-id="419">（2）灵活独立。服务应该具有高内聚性，适当粒度的服务构件能使服务在各角度进行服务装配；通过松散耦合技术减少服务消费者和提供者间技术依赖性。</p><p class="text-idt25" data-id="420">（3）高耦合性。划分后的服务之间的耦合度应该尽量小。</p><p class="text-idt25" data-id="421">（4）可执行性。算法的实现是java语言或者是可以被JVM轻松调度的语言。</p><p class="text-idt25" data-id="422">（5）性能。算法执行的时间尽可能少。</p><p class="text-idt25" data-id="423">（6）简单性。算法的机制和参数的理解程度尽可能简单。</p><p class="text-idt25" data-id="424">在聚类过程中，为了满足以上服务划分算法的要求，我们对比了社区发现算法 GN算法（基于边介数的加权无向图聚类算法）、 MCL算法（加权无向图聚类算法）和 ELP算法（加权无向图（有向图）聚类算法）， GN算法具有很好的确定性，且测试结果也比较好。因此本文采取GN算法来实现服务划分。</p><p class="text-idt25" data-id="425">实现该算法的伪代码如下：</p><p class="text-idt25" data-id="426">算法1微服务划分算法</p><p class="text-idt25" data-id="427">1</p><p class="text-idt25" data-id="428">根据公式得到每条边的权重eij</p><p class="text-idt25" data-id="429">2.</p><p class="text-idt25" data-id="430">根据公式得到所有连接边的边介数Bij</p><p class="text-idt25" data-id="431">3.</p><p class="text-idt25" data-id="432">边介数除以权重得到边权比</p><p class="text-idt25" data-id="433">4.</p><p class="text-idt25" data-id="434">whileedges不为空do</p><p class="text-idt25" data-id="435">5.</p><p class="text-idt25" data-id="436">if𝑒∈𝑒𝑑𝑔𝑒𝑠的边权比最高</p><p class="text-idt25" data-id="437">6.</p><p class="text-idt25" data-id="438">移除e并将e存储起来</p><p class="text-idt25" data-id="439">7.</p><p class="text-idt25" data-id="440">ife有多条</p><p class="text-idt25" data-id="441">8.</p><p class="text-idt25" data-id="442">将具有最高边权比的多条e移除并存储</p><p class="text-idt25" data-id="443">9.</p><p class="text-idt25" data-id="444">计算此时的图的模块性𝑄值并存储</p><p class="text-idt25" data-id="445">10.</p><p class="text-idt25" data-id="446">endwhile</p><p class="text-idt25" data-id="447">11.</p><p class="text-idt25" data-id="448">取得𝑄的最大值</p><p class="text-idt25" data-id="449">𝑄</p><p class="text-idt25" data-id="450">𝑚𝑎𝑥</p><p class="text-idt25" data-id="451">以及 𝑄值对应的边</p><p class="text-idt25" data-id="452">12.</p><p class="text-idt25" data-id="453">return</p><p class="text-idt25" data-id="454">𝑄</p><p class="text-idt25" data-id="455">𝑚𝑎𝑥</p><p class="text-idt25" data-id="456">和e</p><p class="text-idt25" data-id="457">13.</p><p class="text-idt25" data-id="458">end</p><p class="text-idt25" data-id="459"> GN算法的逻辑如算法1所示，首先我们根据语义耦合策略得到单体式应用之间的耦合关系图——无向加权图，在此基础上，具体步骤如下：</p><p class="text-idt25" data-id="460">第一步：忽略边的权重，以无权网络计算网络中所有连接边的边介数</p><p class="text-idt25" data-id="461">𝐵</p><p class="text-idt25" data-id="462">𝑖，𝑗</p><p class="text-idt25" data-id="463">；</p><p class="text-idt25" data-id="464">𝐵</p><p class="text-idt25" data-id="465">𝑖，𝑗</p><p class="text-idt25" data-id="466">=</p><p class="text-idt25" data-id="467">𝑘</p><p class="text-idt25" data-id="468">𝑛</p><p class="text-idt25" data-id="469">𝑘</p><p class="text-idt25" data-id="470">(3-7)</p><p class="text-idt25" data-id="471">第二步：将边介数除以对应边的权重得到边权比</p><p class="text-idt25" data-id="472">𝑤</p><p class="text-idt25" data-id="473">𝑖，𝑗</p><p class="text-idt25" data-id="474">；</p><p class="text-idt25" data-id="475">𝑤</p><p class="text-idt25" data-id="476">𝑖，𝑗</p><p class="text-idt25" data-id="477">=</p><p class="text-idt25" data-id="478">𝐵</p><p class="text-idt25" data-id="479">𝑖，𝑗</p><p class="text-idt25" data-id="480">𝑒</p><p class="text-idt25" data-id="481">𝑖，𝑗</p><p class="text-idt25" data-id="482">(3-8)</p><p class="text-idt25" data-id="483">第三步：找到边权比最高的边将它移除，并计算图的模块性𝑄函数，在计算中当边权比最高的边由多条时，同时移除这些边，并将此时移除的边和𝑄值进行存储；</p><p class="text-idt25" data-id="484">第四步：重复步骤（1）、（2），直到图中所有的边均被移除；</p><p class="text-idt25" data-id="485">第五步：GN算法划分结束后，取出𝑄值最大时的序号，在原始矩阵中依次去除截止到该次划分的边，得出最终连通矩阵，矩阵的值为权值。</p><p class="text-idt25" data-id="486">综上，我们的服务划分算法可以有效的将单体式应用划分为相应的微服务集合，且通过实验验证，得到的微服务具有较高的复用率，并且能够降低微服务平台中应用的代码冗余率，缩小整个的平台代码量。</p><p class="text-idt25" data-id="487">3.4 本章小结</p><p class="text-idt25" data-id="488">本章首先分析了当前服务划分算法以及存在的不足及挑战，然后详细叙述了微服务划分模型的建立的理论基础以及建立的过程，最后介绍了在建立服务划分模型基础上，详细介绍了微服务划分策略的思路以及伪代码的实现。</p><p class="text-idt25" data-id="489">第四章性能感知的微服务选择策略</p><p class="text-idt25" data-id="490">在我们的微服务平台中，微服务路径选择的基本工作流中，首先需要根据应用需求创建微服务实例，之后应用系统发送处理任务请求到平台。当平台接收到处理任务时，首先分析任务的结构，包括每个子任务的类型，子任务之间的关系，每个子任务之间的输入输出信息，为了优化任务处理效率，平台需要提供一个最优的微服务路径。本章首先分析了当前服务选择算法的不足，例如没有考虑在线服务的细粒度的在线处理能力和任务的特征，然后综合考虑微服务实例的处理能力，处理任务的特征以及微服务实例之间的数据传输条件建立了细粒度的性能预测模型，基于提出的性能预测模型，提出一种新颖的性能感知的服务路径选择算法。</p><p class="text-idt25" data-id="491">4.1传统的服务选择算法概述</p><p class="text-idt25" data-id="492">当前国内外有许多关于服务选择算法的研究，为了在许多具有相同功能的 Web服务中选择出符合用户需求的服务，处了要考虑功能需求，也要注重服务的非功能属性，其中包括花费、可用性、响应时间和吞吐量等，这些 QoS的度量将会对服务选择的准确性产生重要影响，因此，基于 QoS度量在 Web服务选择中引起了许多学者的关注。</p><p class="text-idt25" data-id="493">4.1.1基于静态QoS的服务选择策略</p><p class="text-idt25" data-id="494">目前在服务计算领域中，QoS作为一个重要标准，在服务选择过程中受到越来越多的关注。近年来已经提出了各种QoS感知服务选择方法。 Zeng[40]等人在以质量为驱动的服务选择方法的研究中，主要考虑多个属性 QoS和总体约束条件，并在服务选择中的 QoS中加入了用户权重，体现了服务选择中用户权重的重要作用，并且运用混合证书规划模型来挑选出最优的候选服务。但是，其中很少考虑服务之间的QoS相关性，从而导致一些性能问题。 QoS相关可以定义为服务的某些QoS属性不仅依赖于服务本身，而且还与其他服务相关。由于这种相关性将影响 QoS值，因此在生成具有最佳 QoS值的复合服务时，研究如何选择适当的候选服务同时考虑 QoS相关性是很重要，因此 Deng S G[8]等人提出了一种新的服务选择方法，称为相关感知的服务修剪方法（ CASP）。它通过考虑可以集成到最佳组合服务中的所有服务来管理QoS相关性并且修剪不是最优候选服务的服务。最后实验表明，该方法可以管理服务之间复杂的相关性，并显着提高生成的组合服务的QoS值。</p><p class="text-idt25" data-id="495">基于微服务架构的云平台提供了各种各样的微服务，每种微服务能够提供一个具体的数据处理功能，例如数据收集，数据传输，数据特征提取以及数据分类，并且相同功能的微服务实例能够被创建来响应网络应用中实时的服务请求。在执行过程中，从微服务实例池中选择的并且顺序执行的微服务实例组成一条微服务路径。然而，在运行时，不同的微服务实例有不同的资源配置和运行时处理能力，能够提供不同的Qos。因此，制定高效的服务选择策略对于微服务平台性能有重要的影响。但是这些基于QoS的服务选择算法只考虑静态的Qos特征，例如响应性、可用性、和吞吐量，并没有考虑选择的服务实例运行时的特征。应用中的一个子任务执行完成后，之后的服务实例的Qos会随着时间动态改变。因此在执行大规模视频任务期间，一个预定义的最优的服务组合可能是无效的。</p><p class="text-idt25" data-id="496">另外，还有一些动态的自适应的算法提出优化服务组合整体的 Qos[7][8]，文献[11][12]提出了云计算平台中性能感知的服务选择和组合方案。这些方法选择合适的组件服务来创建最优的服务组合，并且能够根据服务提供平台中的各种改变动态的改变最优的服务组合。但是这些方法没有考虑视频处理任务细粒度特征，这些特征对视频任务总的执行时间和服务资源的性能具有重要的影响。</p><p class="text-idt25" data-id="497">4.1.2动态的自适应的服务选择策略</p><p class="text-idt25" data-id="498">由于QoS的不确定性，目前还有一些学者在进行服务选择时，考虑到动态的自适应更新服务选择方法。Tian Huat Tan等人[10]等人提出了一种基于遗传算法的自动化方法来计算恢复计划，该计划可以保证恢复后的组合服务的功能特性的满足。Wang等人[11]提出了一种利用多智能体强化学习来保证服务组合适应性的方法。他们运用博弈论来决定服务优化方向。Peng等人[12]提出了一种自适应方法rEDA，以支持动态QoS感知服务组合的重新优化。Kwonyong Lee[20]等人提出了一种面向服务的网络虚拟化环境中的自适应服务路径选择算法，它可以保证QoS并同时平衡负载。所提出的算法从在虚拟机上运行的多个候选服务实例中选择适当的组件服务，并创建满足用户的QoS要求的最佳服务路径。该算法还可以根据各种变化动态适应最优服务路径。由于所提出的算法处理称为NP-complete的多约束路径选择问题的变化，文中使用蚁群优化算法来表达问题。实验结果表明，该算法在保证同时平衡负载的同时保证了用户的最大QoS，并根据情境变化适应最优服务路径。另外为了优化服务选择，减少服务选择耗费的时间，Skyline服务也被用于缩短服务选择的计算时间。Alrifai等人[7]专注于一种基于QoS的Web服务组合方法，从Skyline服务中选择候选服务，以此减少候选服务的个数，这样可以减少服务选择的时间。</p><p class="text-idt25" data-id="499">这些方法选择合适的服务来创建最优的服务组合，并且能够根据服务提供平台中的各种改变动态的改变最优的服务组合。但是这些方法没有考虑处理任务细粒度特征，这些特征对视频任务总的执行时间和服务资源的性能具有重要的影响。</p><p class="text-idt25" data-id="500">4.1.3传统的服务路径选择算法不足及解决方案</p><p class="text-idt25" data-id="501">为了优化微服务路径选择来提高任务处理效率，在进行微服务选择时不仅需要考虑微服务实例的在线的处理能力，还需综合考虑任务的特征以及微服务实例之间的传输条件，这就需要制定高效的服务选择策略。另外一方面，为了保证服务路径总是最优，我们需要自适应的更新的服务选择，即能够动态更新服务路径。</p><p class="text-idt25" data-id="502">在基于微服务架构的云平台中我们提出了一种新颖的性能感知的服务路径选择方法（PSPAS）。首先为了优化服务路径，我们提出了一种微服务实例的性能模型，主要包括数据处理时间模型和时间传输时间模型。文中通过回归分析预测技术来预测每个子任务中微服务实例的执行时间，用通用的表达式来表示时间传输模型；文中性能预测模型，综合考虑微服务实例的实时的处理能力，任务的特征和微服务实例之间的数据传输条件。然后基于已经建立的性能预测模型，我们提出一种性能感知的服务路径选择策略（PSPAS）。主要包括两个阶段：初始化路径选择阶段，基于性能预测模型，构建有向加权图，使用Viterbi算法构建最优服务路径；自适应服务路径更新阶段，在任务执行过程中，基于路径搜索空间缩减原理实时更新服务路径。</p><p class="text-idt25" data-id="503">本文提出的性能感知的服务路径选择策略在进行服务路径选择时充分考虑了微服务实例的实时的处理能力、以及任务的特征和微服务实例间的传输条件，并且可以自适应的动态更新服务路径，保证了高效的应用执行效率。</p><p class="text-idt25" data-id="504">4.2微服务实例性能预测模型</p><p class="text-idt25" data-id="505">4.2.1问题描述</p><p class="text-idt25" data-id="506">在基于微服务的云平台中，任务的核心工作流程可以描述为一个任务处理流水线，其包括多个处理子任务，例如视频预处理、目标分割、目标的形状特征和纹理特征以及基于机器学习的目标分类。每一个处理子任务可以从一组具有相同功能的微服务实例中选择一个最优的微服务实例，整个应用处理流水线可以看成由选择的微服务实例顺序执行完成的。</p><p class="text-idt25" data-id="507">假设P是一个微服务应用的处理流水线，能够被分成n个顺序执行的子务，𝑃=</p><p class="text-idt25" data-id="508">𝑃</p><p class="text-idt25" data-id="509">𝑖</p><p class="text-idt25" data-id="510">𝑖=1，2，…，𝑛</p><p class="text-idt25" data-id="511">。我们定义微服务类集合𝑆=</p><p class="text-idt25" data-id="512">𝑆</p><p class="text-idt25" data-id="513">𝑖</p><p class="text-idt25" data-id="514">𝑖=1，2，…，𝑛</p><p class="text-idt25" data-id="515">。每个微服务类Si由所有的微服务实例</p><p class="text-idt25" data-id="516">𝑠</p><p class="text-idt25" data-id="517">𝑖𝑗</p><p class="text-idt25" data-id="518">（j=1，2，…，</p><p class="text-idt25" data-id="519">j</p><p class="text-idt25" data-id="520">i，</p><p class="text-idt25" data-id="521">j</p><p class="text-idt25" data-id="522">i</p><p class="text-idt25" data-id="523">代表微服务类</p><p class="text-idt25" data-id="524">𝑆</p><p class="text-idt25" data-id="525">𝑖</p><p class="text-idt25" data-id="526">中微服务实例的个数）组成的，在每个微服务类中的微服务实例具有相同的功能，但是具有不同的执行效率。每一个子任务</p><p class="text-idt25" data-id="527">𝑃</p><p class="text-idt25" data-id="528">𝑖</p><p class="text-idt25" data-id="529">由微服务类</p><p class="text-idt25" data-id="530">𝑆</p><p class="text-idt25" data-id="531">𝑖</p><p class="text-idt25" data-id="532">中的一个微服务实例</p><p class="text-idt25" data-id="533">𝑠</p><p class="text-idt25" data-id="534">𝑖.</p><p class="text-idt25" data-id="535">执行。子任务</p><p class="text-idt25" data-id="536">𝑃</p><p class="text-idt25" data-id="537">𝑖</p><p class="text-idt25" data-id="538">的执行时间</p><p class="text-idt25" data-id="539">𝑇</p><p class="text-idt25" data-id="540">𝑖</p><p class="text-idt25" data-id="541">定义为：</p><p class="text-idt25" data-id="542">𝑇</p><p class="text-idt25" data-id="543">𝑖</p><p class="text-idt25" data-id="544">=</p><p class="text-idt25" data-id="545">𝑇</p><p class="text-idt25" data-id="546">𝑖</p><p class="text-idt25" data-id="547">𝑐</p><p class="text-idt25" data-id="548">+</p><p class="text-idt25" data-id="549">𝑇</p><p class="text-idt25" data-id="550">𝑖</p><p class="text-idt25" data-id="551">𝑠</p><p class="text-idt25" data-id="552">(4-1)</p><p class="text-idt25" data-id="553">其中</p><p class="text-idt25" data-id="554">𝑇</p><p class="text-idt25" data-id="555">𝑖</p><p class="text-idt25" data-id="556">𝑐</p><p class="text-idt25" data-id="557">是微服务实例</p><p class="text-idt25" data-id="558">𝑠</p><p class="text-idt25" data-id="559">𝑖.</p><p class="text-idt25" data-id="560">数据处理的执行时间，</p><p class="text-idt25" data-id="561">𝑇</p><p class="text-idt25" data-id="562">𝑖</p><p class="text-idt25" data-id="563">𝑠</p><p class="text-idt25" data-id="564">是上行微服务实例</p><p class="text-idt25" data-id="565">𝑠</p><p class="text-idt25" data-id="566">𝑖−1.</p><p class="text-idt25" data-id="567">到下行微服务实例</p><p class="text-idt25" data-id="568">𝑠</p><p class="text-idt25" data-id="569">𝑖.</p><p class="text-idt25" data-id="570">的数据传输时间。</p><p class="text-idt25" data-id="571">我们定义微服务路径SP，SP是顺序的微服务集合</p><p class="text-idt25" data-id="572">𝑠</p><p class="text-idt25" data-id="573">1.</p><p class="text-idt25" data-id="574">，</p><p class="text-idt25" data-id="575">𝑠</p><p class="text-idt25" data-id="576">2.</p><p class="text-idt25" data-id="577">，…，</p><p class="text-idt25" data-id="578">𝑠</p><p class="text-idt25" data-id="579">𝑛.</p><p class="text-idt25" data-id="580">，其中</p><p class="text-idt25" data-id="581">𝑠</p><p class="text-idt25" data-id="582">𝑖.</p><p class="text-idt25" data-id="583">是微服务类</p><p class="text-idt25" data-id="584">𝑆</p><p class="text-idt25" data-id="585">𝑖</p><p class="text-idt25" data-id="586">中的微服务实例。服务路径SP决定了任务P的执行时间。因此，任务P总的执行时间为：</p><p class="text-idt25" data-id="587">𝑇=</p><p class="text-idt25" data-id="588">𝑖=1</p><p class="text-idt25" data-id="589">𝑛</p><p class="text-idt25" data-id="590">𝑇</p><p class="text-idt25" data-id="591">𝑖</p><p class="text-idt25" data-id="592">(4-2)</p><p class="text-idt25" data-id="593">对于处理任务P，我们的目标是从所有合理的微服务路径中选择最优的微服务路径，能够最小化处理任务P的执行时间T。</p><p class="text-idt25" data-id="594">4.2.2性能预测模型</p><p class="text-idt25" data-id="595">上一小节描述了主要问题，我们的主要目标是得到处理任务的执行时间，并且使T的值最小。为了最优化服务路径选择，我们需要量化每个微服务实例</p><p class="text-idt25" data-id="596">𝑠</p><p class="text-idt25" data-id="597">𝑖𝑗</p><p class="text-idt25" data-id="598">即子任务</p><p class="text-idt25" data-id="599">𝑃</p><p class="text-idt25" data-id="600">𝑖</p><p class="text-idt25" data-id="601">的执行时间</p><p class="text-idt25" data-id="602">𝑇</p><p class="text-idt25" data-id="603">𝑖𝑗</p><p class="text-idt25" data-id="604">。根据公式(4-1)可以得出</p><p class="text-idt25" data-id="605">𝑇</p><p class="text-idt25" data-id="606">𝑖𝑗</p><p class="text-idt25" data-id="607">为数据执行时间</p><p class="text-idt25" data-id="608">𝑇</p><p class="text-idt25" data-id="609">𝑖𝑗</p><p class="text-idt25" data-id="610">𝑐</p><p class="text-idt25" data-id="611">与数据传输时间</p><p class="text-idt25" data-id="612">𝑇</p><p class="text-idt25" data-id="613">𝑖𝑗</p><p class="text-idt25" data-id="614">𝑠</p><p class="text-idt25" data-id="615">之和。</p><p class="text-idt25" data-id="616">微服务平台应用执行的过程中，微服务实例的执行时间可能是不断发生变化的，我们需要根据微服务实例的状态以及任务的特征来精确预测每个微服务实例的执行时间，并基于此制定合理的服务选择策略，提高应用的执行效率。为此需要建立一个精准的微服务性能预测模型。</p><p class="text-idt25" data-id="617">然而，由于不用的输入文件可能具有不同的帧率、码率、以及时长，同时，微服务实例的资源状态也不同，导致每个微服务实例的数据处理时间可能会动态变化，因此，如何得到实时的服务的数据处理时间并构建精确的性能预测模型是一个关键且困难的技术点。</p><p class="text-idt25" data-id="618">为此，本文分析微服务实例处理时间的影响因素，将性能预测模型分为两部分，第一部分为数据处理时间模型即得到数据执行时间</p><p class="text-idt25" data-id="619">𝑇</p><p class="text-idt25" data-id="620">𝑖𝑗</p><p class="text-idt25" data-id="621">𝑐</p><p class="text-idt25" data-id="622">，第二部分为数据传输时间模型即得到数据传输时间</p><p class="text-idt25" data-id="623">𝑇</p><p class="text-idt25" data-id="624">𝑖𝑗</p><p class="text-idt25" data-id="625">𝑠</p><p class="text-idt25" data-id="626">，性能预测模型为两部分之和即</p><p class="text-idt25" data-id="627">𝑇</p><p class="text-idt25" data-id="628">𝑖𝑗</p><p class="text-idt25" data-id="629">。</p><p class="text-idt25" data-id="630">数据执行时间</p><p class="text-idt25" data-id="631">𝑇</p><p class="text-idt25" data-id="632">𝑖𝑗</p><p class="text-idt25" data-id="633">𝑐</p><p class="text-idt25" data-id="634">由数据处理时间模型得到。每一个微服务实例的数据的执行时间</p><p class="text-idt25" data-id="635">𝑇</p><p class="text-idt25" data-id="636">𝑖𝑗</p><p class="text-idt25" data-id="637">𝑐</p><p class="text-idt25" data-id="638">受多种因素影响，例如任务的特征、微服务平台的当前资源状况。因此我们使用线性回归模型来表示数据处理时间模型。线性回归模型中的参数W在本文中我们使用机器学习的方法来训练得到。为了得到精确的数据处理时间模型，我们的训练数据是通过在云平台上运行目标跟踪算法得到的真实数据包括1000个具有不同分辨率和不同数据大小的视频文件，其中700个视频文件作为</p><p class="text-idt25" data-id="639">训练数据集，300个视频文件作为测试数据集。</p><p class="text-idt25" data-id="640">假设在微服务实例</p><p class="text-idt25" data-id="641">𝑠</p><p class="text-idt25" data-id="642">𝑖𝑗</p><p class="text-idt25" data-id="643">上运行的视频子任务</p><p class="text-idt25" data-id="644">𝑃</p><p class="text-idt25" data-id="645">𝑖</p><p class="text-idt25" data-id="646">由向量𝑋=</p><p class="text-idt25" data-id="647">𝑥</p><p class="text-idt25" data-id="648">1，…，</p><p class="text-idt25" data-id="649">𝑥</p><p class="text-idt25" data-id="650">𝑚</p><p class="text-idt25" data-id="651">∈</p><p class="text-idt25" data-id="652">𝑅</p><p class="text-idt25" data-id="653">𝑚</p><p class="text-idt25" data-id="654">表示，</p><p class="text-idt25" data-id="655">𝑥</p><p class="text-idt25" data-id="656">𝑖</p><p class="text-idt25" data-id="657">为子任务的特征值，m表示预测模型中特征值的数量。模型的特征值包括视频任务的信息，例如视频的分辨率，视频文件大小，以及微服务资源的描述，例如 CPU的核数、 CPU的时钟频率、 CPU的占有率、内存的使用率、内存带宽。由此可知，我们的预测模型不仅考虑了微服务实例历史资源状态和当前的资源状态，也综合考虑了视频任务特征对数据执行时间的影响。在我们的回归预测模型中，为了获得一个更好的线性回归模型，我们对每个特征值取</p><p class="text-idt25" data-id="658">𝑙𝑜𝑔</p><p class="text-idt25" data-id="659">2</p><p class="text-idt25" data-id="660">。我们的回归函数如下：</p><p class="text-idt25" data-id="661">𝑓</p><p class="text-idt25" data-id="662">𝑊，𝑋</p><p class="text-idt25" data-id="663">=</p><p class="text-idt25" data-id="664">𝑙=1</p><p class="text-idt25" data-id="665">𝑚</p><p class="text-idt25" data-id="666">𝑤</p><p class="text-idt25" data-id="667">𝑙</p><p class="text-idt25" data-id="668">𝑙𝑜𝑔</p><p class="text-idt25" data-id="669">2</p><p class="text-idt25" data-id="670">𝑥</p><p class="text-idt25" data-id="671">𝑙</p><p class="text-idt25" data-id="672">(4-3)</p><p class="text-idt25" data-id="673">其中𝑊=</p><p class="text-idt25" data-id="674">𝑤</p><p class="text-idt25" data-id="675">0</p><p class="text-idt25" data-id="676">，</p><p class="text-idt25" data-id="677">𝑤</p><p class="text-idt25" data-id="678">1</p><p class="text-idt25" data-id="679">…</p><p class="text-idt25" data-id="680">𝑤</p><p class="text-idt25" data-id="681">𝑚</p><p class="text-idt25" data-id="682">是模型的参数向量。在视频任务处理流水线中，每一个子任务（不包括第一个子任务）的输入都是上一个子任务的输出而且已经不是原始的视频文件。然而原始的视频文件对于每个子任务的执行时间有直接的影响，所以线性回归函数可以应用到任意一个子任务的微服务实例。</p><p class="text-idt25" data-id="683">为了估量本文中回归模型得到的预测值𝑓(𝑥)与真实值的不一致程度，我们使用平方损失函数作为本文的损失函数。损失函数是经验风险函数的核心部分也是结构风险函数的重要组成部分。为了得到训练数据集中所有数据的预测能力，我们使用模型的结构风险函数来表示。模型的结构风险函数包括经验风险和正则项，如表达式（4-4），为了防止经验风险出现过，度拟合的问题，我们引入正则化项，通过降低模型复杂度来防止过度拟合的出现。因此得到模型的结构风险函数，如下：</p><p class="text-idt25" data-id="684">argmin</p><p class="text-idt25" data-id="685">𝑊</p><p class="text-idt25" data-id="686">𝑓</p><p class="text-idt25" data-id="687">𝑊，𝑋</p><p class="text-idt25" data-id="688">−</p><p class="text-idt25" data-id="689">log</p><p class="text-idt25" data-id="690">2</p><p class="text-idt25" data-id="691">𝑡</p><p class="text-idt25" data-id="692">𝑎𝑐</p><p class="text-idt25" data-id="693">2</p><p class="text-idt25" data-id="694">+𝜆</p><p class="text-idt25" data-id="695">𝑊</p><p class="text-idt25" data-id="696">2</p><p class="text-idt25" data-id="697">(4-4)</p><p class="text-idt25" data-id="698">其中</p><p class="text-idt25" data-id="699">𝑡</p><p class="text-idt25" data-id="700">𝑎𝑐</p><p class="text-idt25" data-id="701">是子任务的实际执行时间，λ是回归参数。基于从云平台中训练的数据集，回归模型通过NAG算法[17]训练得到。参数向量W训练得到后，新的执行时间的</p><p class="text-idt25" data-id="702">𝑙𝑜𝑔</p><p class="text-idt25" data-id="703">2</p><p class="text-idt25" data-id="704">值能够得到。最后我们可以根据微服务实例相应的回归模型预测出每个微服务实例的执行时间</p><p class="text-idt25" data-id="705">𝑇</p><p class="text-idt25" data-id="706">𝑖𝑗</p><p class="text-idt25" data-id="707">𝑐</p><p class="text-idt25" data-id="708">。</p><p class="text-idt25" data-id="709">数据传输时间</p><p class="text-idt25" data-id="710">𝑇</p><p class="text-idt25" data-id="711">𝑖𝑗</p><p class="text-idt25" data-id="712">𝑠</p><p class="text-idt25" data-id="713">由数据传输时间模型得到。为了得到数据传输时间模型的表达式，我们定义了一个源子任务</p><p class="text-idt25" data-id="714">𝑃</p><p class="text-idt25" data-id="715">0</p><p class="text-idt25" data-id="716">和目的子任务</p><p class="text-idt25" data-id="717">𝑃</p><p class="text-idt25" data-id="718">𝑛+1</p><p class="text-idt25" data-id="719">分别代表整个视频处理流水线的开始子任务和结束子任务。我们定义子任务集合P P∪</p><p class="text-idt25" data-id="720">𝑃</p><p class="text-idt25" data-id="721">0</p><p class="text-idt25" data-id="722">，</p><p class="text-idt25" data-id="723">𝑃</p><p class="text-idt25" data-id="724">𝑛+1</p><p class="text-idt25" data-id="725">。另外我们定义了源微服务实例</p><p class="text-idt25" data-id="726">𝑠</p><p class="text-idt25" data-id="727">0，0</p><p class="text-idt25" data-id="728">和目的微服务实例</p><p class="text-idt25" data-id="729">𝑠</p><p class="text-idt25" data-id="730">𝑛+1，0</p><p class="text-idt25" data-id="731">分别代表所有的微服务路径中的开始节点和结束节点。</p><p class="text-idt25" data-id="732">假设在微服务路径中，</p><p class="text-idt25" data-id="733">𝑠</p><p class="text-idt25" data-id="734">𝑖−1，𝑘</p><p class="text-idt25" data-id="735">∈</p><p class="text-idt25" data-id="736">𝑆</p><p class="text-idt25" data-id="737">𝑖−1</p><p class="text-idt25" data-id="738">是微服务实例</p><p class="text-idt25" data-id="739">𝑠</p><p class="text-idt25" data-id="740">𝑖，𝑗</p><p class="text-idt25" data-id="741">的前一个微服务实例。那么从微服务实例</p><p class="text-idt25" data-id="742">𝑠</p><p class="text-idt25" data-id="743">𝑖−1，𝑘</p><p class="text-idt25" data-id="744">到微服务实例</p><p class="text-idt25" data-id="745">𝑠</p><p class="text-idt25" data-id="746">𝑖，𝑗</p><p class="text-idt25" data-id="747">数据传输时间定义为：</p><p class="text-idt25" data-id="748">𝑇</p><p class="text-idt25" data-id="749">𝑖𝑗</p><p class="text-idt25" data-id="750">𝑠</p><p class="text-idt25" data-id="751">𝑘</p><p class="text-idt25" data-id="752">=</p><p class="text-idt25" data-id="753">𝑉𝑜𝑙</p><p class="text-idt25" data-id="754">𝑖</p><p class="text-idt25" data-id="755">𝑁𝑟</p><p class="text-idt25" data-id="756">𝑖𝑗</p><p class="text-idt25" data-id="757">𝑘</p><p class="text-idt25" data-id="758">(4-5)</p><p class="text-idt25" data-id="759">其中</p><p class="text-idt25" data-id="760">𝑉𝑜𝑙</p><p class="text-idt25" data-id="761">𝑖</p><p class="text-idt25" data-id="762">表示从子任务</p><p class="text-idt25" data-id="763">𝑃</p><p class="text-idt25" data-id="764">𝑖−1</p><p class="text-idt25" data-id="765">到子任务</p><p class="text-idt25" data-id="766">𝑃</p><p class="text-idt25" data-id="767">𝑖</p><p class="text-idt25" data-id="768">总的数据传输量，</p><p class="text-idt25" data-id="769">𝑁𝑟</p><p class="text-idt25" data-id="770">𝑖𝑗</p><p class="text-idt25" data-id="771">𝑘</p><p class="text-idt25" data-id="772">表示微服务实例</p><p class="text-idt25" data-id="773">𝑠</p><p class="text-idt25" data-id="774">𝑖−1，𝑘</p><p class="text-idt25" data-id="775">与</p><p class="text-idt25" data-id="776">𝑠</p><p class="text-idt25" data-id="777">𝑖，𝑗</p><p class="text-idt25" data-id="778">之间的数据传输率。</p><p class="text-idt25" data-id="779">假设</p><p class="text-idt25" data-id="780">𝑉𝑜𝑙</p><p class="text-idt25" data-id="781">0</p><p class="text-idt25" data-id="782">是视频处理任务中的元数据。对于在子任务</p><p class="text-idt25" data-id="783">𝑃</p><p class="text-idt25" data-id="784">𝑖</p><p class="text-idt25" data-id="785">，我们定义</p><p class="text-idt25" data-id="786">𝛼</p><p class="text-idt25" data-id="787">𝑖</p><p class="text-idt25" data-id="788">𝑖=1，…，n，</p><p class="text-idt25" data-id="789">𝛼</p><p class="text-idt25" data-id="790">0</p><p class="text-idt25" data-id="791">=1，</p><p class="text-idt25" data-id="792">𝛼</p><p class="text-idt25" data-id="793">𝑛+1</p><p class="text-idt25" data-id="794">=0</p><p class="text-idt25" data-id="795">为输出数据总量与输入数据总量的比值。所以我们能够得到：</p><p class="text-idt25" data-id="796">𝑉𝑜𝑙</p><p class="text-idt25" data-id="797">𝑖</p><p class="text-idt25" data-id="798">=</p><p class="text-idt25" data-id="799">𝛼</p><p class="text-idt25" data-id="800">𝑖−1</p><p class="text-idt25" data-id="801">∗</p><p class="text-idt25" data-id="802">𝑉𝑜𝑙</p><p class="text-idt25" data-id="803">𝑖−1</p><p class="text-idt25" data-id="804">∗</p><p class="text-idt25" data-id="805">𝛼</p><p class="text-idt25" data-id="806">𝑖</p><p class="text-idt25" data-id="807">(4-6)</p><p class="text-idt25" data-id="808">输出数据总量与输入数据总量的比值α可以由离线实验得到，数据传输率</p><p class="text-idt25" data-id="809">𝑁𝑟</p><p class="text-idt25" data-id="810">𝑖𝑗</p><p class="text-idt25" data-id="811">𝑘</p><p class="text-idt25" data-id="812">可以由专门的测量工具测量得到。</p><p class="text-idt25" data-id="813">综上，可以看出我们的性能预测模型</p><p class="text-idt25" data-id="814">𝑇</p><p class="text-idt25" data-id="815">𝑖𝑗</p><p class="text-idt25" data-id="816">在预测每个微服务处理能力的时候，不仅考虑了服务在线的资源特征、任务的特征，还考虑了各个文件本身的特性，可以准确的计算微服务的处理时长。</p><p class="text-idt25" data-id="817">4.3微服务路径选择策略</p><p class="text-idt25" data-id="818">上一节中我们得到了性能预测模型，在此基础上，我们提出了性能感知的服务路径选择策略，主要包括两个阶段服务路径初始化阶段和服务路径动态更新阶段，本小节将详细介绍这两个阶段。</p><p class="text-idt25" data-id="819">4.3.1微服务路径初始选择策略</p><p class="text-idt25" data-id="820">在分布式的流水线应用处理场景中，一个应用的最终完成时间是由每一个子任务完成的时间之和决定的，如果在微服务路径初始选择时，不考虑各个微服务实例的细粒度的资源状态以及任务特征，一方面选择的微服务实例可能不是当前最优的微服务实例，造成当前的路径不是当前的最优选择，另一方面也会导致整个应用不能选择出最优的选择，降低了应用的处理效率，因此制定合理的微服务路径初始选择策略对于提升整个微服务应用的处理效率至关重要。</p><p class="text-idt25" data-id="821">上节本文结合微服务应用的特征、平台微服务实例细粒度特征以及微服务实例间网络带宽的特点构建了时间预测模型。本节将提出一种基于时间预测模型的微服务路径初始选择策略，该策略主要用于在微服务应用在初始化状态下如何选择当前最优的微服务路径。</p><p class="text-idt25" data-id="822">基于上节提出的性能预测模型，我们能构建一个分层的有向加权图G，如图4-1所示。</p><p class="text-idt25" data-id="823">图4-1分层的有向加权图</p><p class="text-idt25" data-id="824">在图G中，每一层代表一个微服务类</p><p class="text-idt25" data-id="825">𝑆</p><p class="text-idt25" data-id="826">𝑖</p><p class="text-idt25" data-id="827">，每一个微服务类由多个节点组成，每一个节点代表一个微服务实例</p><p class="text-idt25" data-id="828">𝑠</p><p class="text-idt25" data-id="829">𝑖𝑗</p><p class="text-idt25" data-id="830">∈</p><p class="text-idt25" data-id="831">𝑆</p><p class="text-idt25" data-id="832">𝑖</p><p class="text-idt25" data-id="833">。在图G中第</p><p class="text-idt25" data-id="834">𝑆</p><p class="text-idt25" data-id="835">𝑖</p><p class="text-idt25" data-id="836">层的节点</p><p class="text-idt25" data-id="837">𝑠</p><p class="text-idt25" data-id="838">𝑖𝑗</p><p class="text-idt25" data-id="839">与第</p><p class="text-idt25" data-id="840">𝑆</p><p class="text-idt25" data-id="841">𝑖−1</p><p class="text-idt25" data-id="842">层的节点</p><p class="text-idt25" data-id="843">𝑠</p><p class="text-idt25" data-id="844">𝑖−1，𝑘</p><p class="text-idt25" data-id="845">都对应有一个边</p><p class="text-idt25" data-id="846">𝑒</p><p class="text-idt25" data-id="847">𝑖𝑗</p><p class="text-idt25" data-id="848">𝑘</p><p class="text-idt25" data-id="849">，边</p><p class="text-idt25" data-id="850">𝑒</p><p class="text-idt25" data-id="851">𝑖𝑗</p><p class="text-idt25" data-id="852">𝑘</p><p class="text-idt25" data-id="853">是数据处理时间</p><p class="text-idt25" data-id="854">T</p><p class="text-idt25" data-id="855">ij</p><p class="text-idt25" data-id="856">c</p><p class="text-idt25" data-id="857">和数据传输时间</p><p class="text-idt25" data-id="858">𝑇</p><p class="text-idt25" data-id="859">𝑖𝑗</p><p class="text-idt25" data-id="860">𝑠</p><p class="text-idt25" data-id="861">𝑘</p><p class="text-idt25" data-id="862">之和。微服务路径的权重是路径中所有边的权重之和。因此，我们的目标是在所有合理的微服务路径中选择具有最小路径权重的一组微服务组合SP。</p><p class="text-idt25" data-id="863">𝑆𝑃=</p><p class="text-idt25" data-id="864">s</p><p class="text-idt25" data-id="865">00</p><p class="text-idt25" data-id="866">，</p><p class="text-idt25" data-id="867">s</p><p class="text-idt25" data-id="868">1.</p><p class="text-idt25" data-id="869">，…，</p><p class="text-idt25" data-id="870">s</p><p class="text-idt25" data-id="871">n.</p><p class="text-idt25" data-id="872">，</p><p class="text-idt25" data-id="873">s</p><p class="text-idt25" data-id="874">n+1，0</p><p class="text-idt25" data-id="875">(4-7)</p><p class="text-idt25" data-id="876">综上所述，这是一个经典的动态规划问题，因此我们可以使用维特比算法来获得最短路径SP。详细的服务路径初始化策略如下：</p><p class="text-idt25" data-id="877">步骤1：基于性能预测模型可以构建出分层的加权有向图G，图中的权重即为数据处理时间和数据传输时间之和。</p><p class="text-idt25" data-id="878">步骤2：从</p><p class="text-idt25" data-id="879">𝑆</p><p class="text-idt25" data-id="880">0</p><p class="text-idt25" data-id="881">出发，对于到第一层的节点，算出</p><p class="text-idt25" data-id="882">𝑆</p><p class="text-idt25" data-id="883">0</p><p class="text-idt25" data-id="884">到他们的距离</p><p class="text-idt25" data-id="885">𝑆</p><p class="text-idt25" data-id="886">0</p><p class="text-idt25" data-id="887">，</p><p class="text-idt25" data-id="888">𝑆</p><p class="text-idt25" data-id="889">1，1</p><p class="text-idt25" data-id="890">，</p><p class="text-idt25" data-id="891">𝑆</p><p class="text-idt25" data-id="892">0</p><p class="text-idt25" data-id="893">，</p><p class="text-idt25" data-id="894">𝑆</p><p class="text-idt25" data-id="895">1，2</p><p class="text-idt25" data-id="896">，…，</p><p class="text-idt25" data-id="897">𝑆</p><p class="text-idt25" data-id="898">0</p><p class="text-idt25" data-id="899">，</p><p class="text-idt25" data-id="900">𝑆</p><p class="text-idt25" data-id="901">1，n</p><p class="text-idt25" data-id="902">，因此只有一步，这些都是</p><p class="text-idt25" data-id="903">𝑆</p><p class="text-idt25" data-id="904">0</p><p class="text-idt25" data-id="905">到他们的最短距离。</p><p class="text-idt25" data-id="906">步骤3：对于第二层节点要找出他们到</p><p class="text-idt25" data-id="907">𝑆</p><p class="text-idt25" data-id="908">0</p><p class="text-idt25" data-id="909">的最短距离，要通过第一层中的其中一个节点，所以对第二层的任意节点，我们都要计算n次，共计算</p><p class="text-idt25" data-id="910">𝑛</p><p class="text-idt25" data-id="911">2</p><p class="text-idt25" data-id="912">次，并一一比较得到到第二层的最短路径。</p><p class="text-idt25" data-id="913">步骤4：同步骤三，这一步我们也会共计算</p><p class="text-idt25" data-id="914">𝑛</p><p class="text-idt25" data-id="915">2</p><p class="text-idt25" data-id="916">次。</p><p class="text-idt25" data-id="917">重复以上步骤直到任务结束，我们得到了服务路径初始化阶段的最优路径SP。</p><p class="text-idt25" data-id="918">4.3.2服务搜索空间缩减原则</p><p class="text-idt25" data-id="919">上一节介绍了基于性能预测模型的微服务路径选择的初始化策略，对于给定的分层加权有向图 G，上文介绍的最短路径算法就能得到最优服务路径 SP。然而，当一个子任务</p><p class="text-idt25" data-id="920">𝑃</p><p class="text-idt25" data-id="921">𝑖</p><p class="text-idt25" data-id="922">由微服务实例</p><p class="text-idt25" data-id="923">𝑠</p><p class="text-idt25" data-id="924">𝑖.</p><p class="text-idt25" data-id="925">i=1，2，…，n−1</p><p class="text-idt25" data-id="926">完成，下一个微服务实例</p><p class="text-idt25" data-id="927">𝑠</p><p class="text-idt25" data-id="928">𝑖.</p><p class="text-idt25" data-id="929">i=l+1，…，n</p><p class="text-idt25" data-id="930">的资源状态或者服务处理能力已经改变，这就意味着随着微服务应用的子任务的执行完成图G中的权重会发生改变。因此，初始化选择的最优的微服务路径SP就不是当前最优的路径。为了解决这个问题，最直接的找出当前的最优的服务路径的方法就是在每一个子任务执行完成后重复的调用以上最短路径算法。但是这个解决方法有很大的计算时间代价以及对于有许多微服务实例的微服务平台的流水线任务是不合适的。</p><p class="text-idt25" data-id="931">在本节中，我们提出了一个自适应的服务路径更新算法，该算法在在线执行微服务路径选择之前使用 Skyline服务思想，减少可选服务的搜索空间，提高微服务选择的执行效率，得到当前最优的服务路径。以下是详细的服务空间缩减原则步骤：</p><p class="text-idt25" data-id="932">首先我们为每一个子任务定义时间率β：</p><p class="text-idt25" data-id="933">𝛽=</p><p class="text-idt25" data-id="934">𝑇</p><p class="text-idt25" data-id="935">𝑖</p><p class="text-idt25" data-id="936">𝑐</p><p class="text-idt25" data-id="937">𝑇</p><p class="text-idt25" data-id="938">𝑖</p><p class="text-idt25" data-id="939">𝑠</p><p class="text-idt25" data-id="940">(4-7)</p><p class="text-idt25" data-id="941">计算主导型子任务的时间率阈值</p><p class="text-idt25" data-id="942">β</p><p class="text-idt25" data-id="943">c</p><p class="text-idt25" data-id="944">，传输主导型子任务的时间率阈值</p><p class="text-idt25" data-id="945">𝛽</p><p class="text-idt25" data-id="946">𝑠</p><p class="text-idt25" data-id="947">，</p><p class="text-idt25" data-id="948">𝛽</p><p class="text-idt25" data-id="949">𝑐</p><p class="text-idt25" data-id="950">，</p><p class="text-idt25" data-id="951">𝛽</p><p class="text-idt25" data-id="952">𝑠</p><p class="text-idt25" data-id="953">的值通常是实验值，是在微服务平台中通过实验得到的。</p><p class="text-idt25" data-id="954">计算主导型子任务（CDS）：是指在微服务任务流水线中，该子任务的时间率𝛽≥</p><p class="text-idt25" data-id="955">𝛽</p><p class="text-idt25" data-id="956">𝑐</p><p class="text-idt25" data-id="957">。</p><p class="text-idt25" data-id="958">传输主导型子任务（TDS）：是指在微服务任务流水线中，该子任务的时间率𝛽≤</p><p class="text-idt25" data-id="959">𝛽</p><p class="text-idt25" data-id="960">𝑠</p><p class="text-idt25" data-id="961">。</p><p class="text-idt25" data-id="962">计算主导型子任务（ CDS）的执行时间主要是由微服务实例的计算能力所影响，因此我们能忽略子任务的输入数据的传输时间对于服务路径更新的执行效率带来的影响。</p><p class="text-idt25" data-id="963">因此，当子任务</p><p class="text-idt25" data-id="964">𝑃</p><p class="text-idt25" data-id="965">𝑖</p><p class="text-idt25" data-id="966">在微服务平台中运行的时候，我们可以根据路径搜索空间缩减原则（PSSP）来缩减路径搜索空间来提高服务路径更新效率。</p><p class="text-idt25" data-id="967">路径搜索空间缩减原则（PSSP）：</p><p class="text-idt25" data-id="968">i．如果</p><p class="text-idt25" data-id="969">𝑃</p><p class="text-idt25" data-id="970">𝑗</p><p class="text-idt25" data-id="971">是计算主导型子任务，本文在微服务集合</p><p class="text-idt25" data-id="972">𝑆</p><p class="text-idt25" data-id="973">𝑗</p><p class="text-idt25" data-id="974">选择前m个具有最短数据处理时间的微服务实例作为路径选择中的微服务实例集合。</p><p class="text-idt25" data-id="975">ii．如果</p><p class="text-idt25" data-id="976">𝑃</p><p class="text-idt25" data-id="977">𝑗</p><p class="text-idt25" data-id="978">是传输主导型子任务，本文在微服务集合</p><p class="text-idt25" data-id="979">𝑆</p><p class="text-idt25" data-id="980">𝑗</p><p class="text-idt25" data-id="981">中选择前m个具有最短数据传输时间的微服务实例作为路径选中的微服务实例集合。</p><p class="text-idt25" data-id="982">iii．如果</p><p class="text-idt25" data-id="983">𝑃</p><p class="text-idt25" data-id="984">𝑗</p><p class="text-idt25" data-id="985">既不是计算主导型子任务又不是传输主导型子任务，本文在微服务集合</p><p class="text-idt25" data-id="986">𝑆</p><p class="text-idt25" data-id="987">𝑗</p><p class="text-idt25" data-id="988">中选择前m个具有最短的平均执行时间的微服务实例作为路径选择中的微服务实例集合。</p><p class="text-idt25" data-id="989">在PSSP中，m被定义为微服务路径搜索空间缩减参数，通常m≪该子任务对应微服务实例的个数。本文中，我们定义m=3。</p><p class="text-idt25" data-id="990">4.3.3微服务路径动态更新策略</p><p class="text-idt25" data-id="991">根据上述的服务路径搜索空间缩减原则，可以得到一个简化的分层的有向带权子图</p><p class="text-idt25" data-id="992">𝐺</p><p class="text-idt25" data-id="993">1</p><p class="text-idt25" data-id="994">。如图4-2，在</p><p class="text-idt25" data-id="995">𝐺</p><p class="text-idt25" data-id="996">1</p><p class="text-idt25" data-id="997">中，源节点即为第一层的节点代表已经执行的子任务</p><p class="text-idt25" data-id="998">𝑃</p><p class="text-idt25" data-id="999">1</p><p class="text-idt25" data-id="1000">，该子任务在初始化阶段选择微服务实例</p><p class="text-idt25" data-id="1001">𝑠</p><p class="text-idt25" data-id="1002">1，2</p><p class="text-idt25" data-id="1003">来提供服务。而后面的子任务对应的微服务实例，我们根据服务搜索空间缩减原则，只选择性能最好的前3个微服务实例，这样我们就得到了如图4-2的分层的有向带权子图</p><p class="text-idt25" data-id="1004">𝐺</p><p class="text-idt25" data-id="1005">1</p><p class="text-idt25" data-id="1006">，之后我们在子图</p><p class="text-idt25" data-id="1007">𝐺</p><p class="text-idt25" data-id="1008">𝑖</p><p class="text-idt25" data-id="1009">中再次利用维特比算法，得到该子图对应的当前的最优服务路径</p><p class="text-idt25" data-id="1010">𝑆𝑃</p><p class="text-idt25" data-id="1011">2</p><p class="text-idt25" data-id="1012">。从而可以选择出执行第二个子任务</p><p class="text-idt25" data-id="1013">𝑃</p><p class="text-idt25" data-id="1014">2</p><p class="text-idt25" data-id="1015">的微服务实例</p><p class="text-idt25" data-id="1016">𝑠</p><p class="text-idt25" data-id="1017">2，𝑘</p><p class="text-idt25" data-id="1018">，接下来我们根据更新后微服务实例的状态，依据服务搜索空间缩减原则，选择出最优的前3个微服务实例作为节点，就可以构造以微服务实例</p><p class="text-idt25" data-id="1019">𝑠</p><p class="text-idt25" data-id="1020">2，𝑘</p><p class="text-idt25" data-id="1021">为源节点的分层的有向带权子图</p><p class="text-idt25" data-id="1022">𝐺</p><p class="text-idt25" data-id="1023">2</p><p class="text-idt25" data-id="1024">。依次类推，直到我们的任务执行完成。注意根据微服务平台的状态，图</p><p class="text-idt25" data-id="1025">𝐺</p><p class="text-idt25" data-id="1026">𝑖</p><p class="text-idt25" data-id="1027">的每一条边的权重也会更新。之后，我们根据维特比算法重现选择出当前图</p><p class="text-idt25" data-id="1028">𝐺</p><p class="text-idt25" data-id="1029">𝑖</p><p class="text-idt25" data-id="1030">最优路径。最后我们重复以上路径搜索空间缩减原则并且重新选择当前最优路径直到微服务应用执行完成。</p><p class="text-idt25" data-id="1031">图 4-2分层的有向加权子图Gi</p><p class="text-idt25" data-id="1032">4.4微服务路径选择算法实现</p><p class="text-idt25" data-id="1033">上一节我们介绍了微服务路径选择策略的详细步骤，这一节我们将介绍算法的实现。</p><p class="text-idt25" data-id="1034">现有的服务服务路径选择算法中，或者只考虑服务的历史的资源状况，或者只考虑没有任务的特征，所以当前服务计算领域的服务路径选择方法无法满足微服务平台中服务选择需求。因此本文利用机器学习的方法，使用线性回归模型，结合服务运行时资源特性、任务的特征以及输入数据本身的特性求得性能预测模型，在此基础上，提出性能感知的服务路径选择方法（ PSPAS）， PSPAS的主要逻辑如算法2所示：</p><p class="text-idt25" data-id="1035">算法2 性能感知的微服务路径选择算法</p><p class="text-idt25" data-id="1036">1.</p><p class="text-idt25" data-id="1037">基于构建的性能感知模型构建分层的带权有向图G</p><p class="text-idt25" data-id="1038">2.</p><p class="text-idt25" data-id="1039">3.</p><p class="text-idt25" data-id="1040">4.</p><p class="text-idt25" data-id="1041">5.</p><p class="text-idt25" data-id="1042">6.</p><p class="text-idt25" data-id="1043">7.</p><p class="text-idt25" data-id="1044">8.</p><p class="text-idt25" data-id="1045">9.</p><p class="text-idt25" data-id="1046">初始化𝑖=1</p><p class="text-idt25" data-id="1047">while i 不等于ndo</p><p class="text-idt25" data-id="1048">首先计算从</p><p class="text-idt25" data-id="1049">𝑆</p><p class="text-idt25" data-id="1050">0</p><p class="text-idt25" data-id="1051">到第一层节点的最短距离</p><p class="text-idt25" data-id="1052">计算第一层n个节点到第二层n个节点的最短距离</p><p class="text-idt25" data-id="1053">类似步骤4，计算第i层n个节点到第i+1层n个节点的最短距离</p><p class="text-idt25" data-id="1054">𝑖=𝑖+1</p><p class="text-idt25" data-id="1055">重复以上步骤知道任务结束，得到当前最优路径</p><p class="text-idt25" data-id="1056">𝑆𝑃</p><p class="text-idt25" data-id="1057">1</p><p class="text-idt25" data-id="1058">end while</p><p class="text-idt25" data-id="1059">初始化𝑗=1</p><p class="text-idt25" data-id="1060">10.</p><p class="text-idt25" data-id="1061">while应用P没有结束do</p><p class="text-idt25" data-id="1062">11.</p><p class="text-idt25" data-id="1063">在最优路径</p><p class="text-idt25" data-id="1064">𝑆𝑃</p><p class="text-idt25" data-id="1065">1</p><p class="text-idt25" data-id="1066">中调用微服务实例</p><p class="text-idt25" data-id="1067">𝑠</p><p class="text-idt25" data-id="1068">𝑖.</p><p class="text-idt25" data-id="1069">执行子任务</p><p class="text-idt25" data-id="1070">𝑃</p><p class="text-idt25" data-id="1071">𝑖</p><p class="text-idt25" data-id="1072">12.</p><p class="text-idt25" data-id="1073">𝑗=𝑗+1</p><p class="text-idt25" data-id="1074">13.</p><p class="text-idt25" data-id="1075">根据路径搜索空间缩减原则对于还没有执行完的子任务执行路径搜索空间缩减操作</p><p class="text-idt25" data-id="1076">14.</p><p class="text-idt25" data-id="1077">基于路径搜索空间缩减操作的结果重构当前的子图</p><p class="text-idt25" data-id="1078">𝐺</p><p class="text-idt25" data-id="1079">𝑖</p><p class="text-idt25" data-id="1080">15.</p><p class="text-idt25" data-id="1081">使用维特比算法重新选择出当前最优路径</p><p class="text-idt25" data-id="1082">𝑆𝑃</p><p class="text-idt25" data-id="1083">𝑗</p><p class="text-idt25" data-id="1084">16</p><p class="text-idt25" data-id="1085">end while</p><p class="text-idt25" data-id="1086">首先通过性能预测模型构建分层的有向加权图G，之后再根据维特比算法得到初始化的最优服务路径</p><p class="text-idt25" data-id="1087">𝑆𝑃</p><p class="text-idt25" data-id="1088">1</p><p class="text-idt25" data-id="1089">（第3行~第9行），当初始化路径完成后，需要根据微服务实例的状态对服务路径动态更新（第10行~第16行），直到我们的任务执行完成。</p><p class="text-idt25" data-id="1090">4.5 本章小结</p><p class="text-idt25" data-id="1091">本章首先分析了当前的服务选择算法以及不足之处，然后根据微服务平台应用的特点建立性能预测模型，最后介绍了基于性能预测模型的服务路径选择策略以及伪代码的实现。</p><p class="text-idt25" data-id="1092">第五章系统实验及测试</p><p class="text-idt25" data-id="1093">5.1实验环境配置</p><p class="text-idt25" data-id="1094">5.1.1实验硬件环境</p><p class="text-idt25" data-id="1095">本文中实验硬件部分由10台物理服务器组成，10台服务器分别部署在两个机架中，每个机架中有5台服务器，两个机架中的交换机都支持1000 Mbit/ s。为了保证集群的高可用以及容错性，控制节点配置为2个，分别命名为 controller1和 controller2，控制节点用于资源调度、微服务管理、服务路径选择等核心功能，同时，为了更好地利用集群物理资源，将包括控制节点在内的全部物理节点配置为工作节点，除去两个控制节点，其他节点依次命名为 node1~ node8，每一个节点配置用于支持微服务的 Docker容器引擎。整个集群物理服务器配置如下：</p><p class="text-idt25" data-id="1096">表5-1 物理服务器配置列表</p><p class="text-idt25" data-id="1097">类型</p><p class="text-idt25" data-id="1098">CPU类型</p><p class="text-idt25" data-id="1099">CPU数量</p><p class="text-idt25" data-id="1100">内存</p><p class="text-idt25" data-id="1101">服务器数量</p><p class="text-idt25" data-id="1102">1</p><p class="text-idt25" data-id="1103">6 core</p><p class="text-idt25" data-id="1104">2</p><p class="text-idt25" data-id="1105">32GB</p><p class="text-idt25" data-id="1106">4</p><p class="text-idt25" data-id="1107">2</p><p class="text-idt25" data-id="1108">10 core</p><p class="text-idt25" data-id="1109">2</p><p class="text-idt25" data-id="1110">32GB</p><p class="text-idt25" data-id="1111">2</p><p class="text-idt25" data-id="1112">3</p><p class="text-idt25" data-id="1113">8 core</p><p class="text-idt25" data-id="1114">2</p><p class="text-idt25" data-id="1115">32GB</p><p class="text-idt25" data-id="1116">2</p><p class="text-idt25" data-id="1117">4</p><p class="text-idt25" data-id="1118">8 core</p><p class="text-idt25" data-id="1119">2</p><p class="text-idt25" data-id="1120">64GB</p><p class="text-idt25" data-id="1121">2</p><p class="text-idt25" data-id="1122">通过htop来获取每个节点中CPU和内存的使用率，任意两个节点之间的网络传输带宽通过iperf获得。</p><p class="text-idt25" data-id="1123">5.1.2 实验软件配置</p><p class="text-idt25" data-id="1124">目前虽然 Docker已经支持在各种操作系统环境例如 Window、 Linux、 Mac等安装部署，但是考虑到性能以及为了兼容实验室内已有的容器云环境，本文选择在 Linux操作系统环境下进行集群的软件配置和部署。因此，在每个物理节点上都统一安装了内核版本的 GNU/ Linux3.13.0-32- generic x8664的 Ubuntu14.04.1 LTS操作系统以及版本为1.11.1的 Docker Engineer。整个平台的开发工作实在实验室的电脑上进行，以下是具体的软件开发环境：</p><p class="text-idt25" data-id="1125">（1）操作系统Ubuntu14.04.3 LTS桌面版；</p><p class="text-idt25" data-id="1126">（2）程序开发环境：Vim，JetBrains IDEA，Docker；</p><p class="text-idt25" data-id="1127">（3）计算机视觉库：OpenCV 2.4.9；</p><p class="text-idt25" data-id="1128">（4）数据库：Mysql</p><p class="text-idt25" data-id="1129">5.1.3实验数据说明</p><p class="text-idt25" data-id="1130">本文中服务划分算法中的数据我们是部署在中国福州的真实的视频监控系统中获取到的。性能预测模型中的数据集，是使用目标追踪算法实时获取到的，共获取了1000个视频文件，这些文件有不同的分辨率，不同的帧率以及时长；其中700个视频文件用于训练数据集，剩余300个视频文件用于测试数据集。</p><p class="text-idt25" data-id="1131">5.1.4实验中子任务实现</p><p class="text-idt25" data-id="1132">为了测试我们算法的性能，我们实现了两个典型的视频处理任务：视频浓缩和目标检测。这两个任务包含的子任务和详细处理流程如下：每个视频子任务都是根据一个预先定义的工作流程执行的，其中有单独的输入和输出，并且子任务之间有固定的依赖关系。如图5-1所示，视频浓缩应用主要包括以下几个子任务：视频数据输入，GMM背景建模，三帧差分，通道提取，通道优化，拼接、浓缩视频等。</p><p class="text-idt25" data-id="1133">图5-1视频浓缩流程图</p><p class="text-idt25" data-id="1134">如图5-2所示，目标追踪应用主要包括以下几个子任务：视频数据输入，GMM背景建模，三帧差分，预处理，高斯模型，DOG金字塔，尺度空间极值检测，提取特征向量，目标跟踪等。</p><p class="text-idt25" data-id="1135">图5-2目标追踪流程图</p><p class="text-idt25" data-id="1136">5.2实验中任务实现</p><p class="text-idt25" data-id="1137">5.2.1 视频浓缩服务镜像实现</p><p class="text-idt25" data-id="1138">为了测试本文实现的基于领域驱动设计思想的语义耦合的微服务划分算法，本文基于实验室先前工作中实现的视频浓缩算法实现了针对视频浓缩服务请求的功能镜像。在用户请求视频浓缩服务时，微服务平台中的微服务管理模块将视频浓缩服务的源代码调度到服务划分模块，将该服务划分成响应的微服务，在此过程中服务划分模块和服务注册组件通信，完成服务注册功能。</p><p class="text-idt25" data-id="1139">由于我们先前工作中实现的视频浓缩算法的源代码是通过 Maven进行构建的，因此需要在 Maven项目的根目录下创建 Dockerfile文件，然后以 Maven的官方镜像作为基础镜像进行镜像的构建，同时为了减小镜像文件体积，提升从仓库拉取镜像的速度，在构建镜像的过程中需要将编译环境生成的中间文件通过系统命令进行删除。整个Dockerfile文件的代码如下：</p><p class="text-idt25" data-id="1140">FROM maven:3</p><p class="text-idt25" data-id="1141">MAINTAINER yangning 15032801667@163.com</p><p class="text-idt25" data-id="1142">RUN mkdir -p /build/input/output</p><p class="text-idt25" data-id="1143">WORKDIR /build</p><p class="text-idt25" data-id="1144">ENV TASK videoSynopsis.jar</p><p class="text-idt25" data-id="1145">ADD POM.xml .</p><p class="text-idt25" data-id="1146">ADD src src</p><p class="text-idt25" data-id="1147">RUN mvn package mvn test</p><p class="text-idt25" data-id="1148">RUN cp target/$TASK / rm -rf /build rm -rf ~/.m2/*</p><p class="text-idt25" data-id="1149">VOLUME /output</p><p class="text-idt25" data-id="1150">CMD [“java”， “-jar”， “/videoSynopsis.jar”， “$@”]</p><p class="text-idt25" data-id="1151">Dockerfile编写完成后通过以下脚本文件完成镜像构建和上传。</p><p class="text-idt25" data-id="1152">docker build -t controller1:6000/videoSynopsis</p><p class="text-idt25" data-id="1153">docker push controller1:6000/videoSynopsis</p><p class="text-idt25" data-id="1154">5.2.4目标跟踪服务镜像实现</p><p class="text-idt25" data-id="1155">为了测试本文实现的基于领域驱动设计思想的语义耦合的微服务划分算法，需要另一个微服务应用结合视频浓缩服务来验证服务划分算法的性能，本文基于实验室之前工作中实现的目标跟踪算法实现了针对目标跟踪服务请求的功能镜像。与视频浓缩服务请求类似，当用户请求目标跟踪服务时，微服务平台中的微服务管理模块会将目标跟踪服务源代码调度到服务划分模块，并将划分好的微服务注册到服务注册组件。</p><p class="text-idt25" data-id="1156">与视频浓缩算法相同，目标跟踪算法的源代码也是通过 Maven进行构建的，因此需要首先在 Maven项目的根目录下创建 Dockerfile文件，然后以 Maven的官方镜像作为基础镜像进行镜像的构建，同时为了减小镜像文件体积，提升从仓库拉取镜像的速度，在构建镜像的过程中我们将编译环节生产的中间文件通过系统命令进行删除。整个Dockerfile文件的代码如下：</p><p class="text-idt25" data-id="1157">FROM maven:3</p><p class="text-idt25" data-id="1158">MAINTAINER yangning 15032801667@163.com</p><p class="text-idt25" data-id="1159">RUN mkdir -p /build/input/output</p><p class="text-idt25" data-id="1160">WORKDIR /build</p><p class="text-idt25" data-id="1161">ENV TASK objectTracking.jar</p><p class="text-idt25" data-id="1162">ADD POM.xml .</p><p class="text-idt25" data-id="1163">ADD src src</p><p class="text-idt25" data-id="1164">RUN mvn package mvn test</p><p class="text-idt25" data-id="1165">RUN cp target/$TASK / rm -rf /build rm -rf ~/.m2/*</p><p class="text-idt25" data-id="1166">VOLUME /output</p><p class="text-idt25" data-id="1167">CMD [“java”， “-jar”， “/objectTracking.jar”， “$@”]</p><p class="text-idt25" data-id="1168">同样的Dockerfile文件编写完成后通过以下脚本文件完成镜像构建和上传。</p><p class="text-idt25" data-id="1169">docker build -t controller1:6000/objectTracking</p><p class="text-idt25" data-id="1170">docker build controller1:6000/objectTracking</p><p class="text-idt25" data-id="1171">5.3算法效果测试</p><p class="text-idt25" data-id="1172">本节主要基于5.2.3和5.2.4小节实现的视频浓缩服务功能和目标跟踪服务对实验环境以及算法效果进行验证。</p><p class="text-idt25" data-id="1173">5.3.1实验环境测试</p><p class="text-idt25" data-id="1174">首先，为了验证平台中视频浓缩服务镜像和目标跟踪服务镜像的功能的有效性，本文准备了大约10 GB的监控视频数据，这些视频数据均来自中国福州部署的监控视频系统，视频本身采用 H.264进行编码，视频分辨率为1920*1080，码率为25 fps，总时长为10分钟。将1 GB的视频文件放置在 Controller节点启动 Docker计算引擎拉取视频浓缩服务镜像生成视频浓缩服务容器计算实例读取视频数据进行处理，最后生成的浓缩后的视频文件总大小约为24 MB，时长约1分钟。</p><p class="text-idt25" data-id="1175">图5-1原视频文件中的画面</p><p class="text-idt25" data-id="1176">如图5-1是我们原视频文件中的画面，可以看到，该画面存在很多冗余信息，在我们进行目标提取时，检索的速度可能会受影响，因此我们使用视频浓缩技术将原始视频浓缩成比较短的视频文件。</p><p class="text-idt25" data-id="1177">图5-2视频浓缩后的画面</p><p class="text-idt25" data-id="1178">如图5-2所示，是经过视频浓缩技术处理的视频文件的画面，与原始视频文件的画面形成鲜明对比，经过视频浓缩技术处理的文件除去了大量的冗余信息，画面中的有效信息的密集程度在一定程度上有了很大提高，从而得出我们视频浓缩任务的有效性。</p><p class="text-idt25" data-id="1179">5.3.2微服务划分算法效果验证试验</p><p class="text-idt25" data-id="1180">为了验证本文提出的微服务划分算法的效果，本文使用了原平台中两个服务，视频浓缩服务和目标跟踪服务，我们控制用户对两个服务的请求个数为50~100，选取了5个有代表性的视频数据文件，每个视频数据文件的的数据大小以及视频的分辨率、帧率、时长都是不同的。表5-1是实验中数据集的详细信息：</p><p class="text-idt25" data-id="1181">表5-2 视频数据集详细信息表</p><p class="text-idt25" data-id="1182">数据名称</p><p class="text-idt25" data-id="1183">视频数据大小</p><p class="text-idt25" data-id="1184">帧速率</p><p class="text-idt25" data-id="1185">时长</p><p class="text-idt25" data-id="1186">服务请求个数</p><p class="text-idt25" data-id="1187">Dataset1</p><p class="text-idt25" data-id="1188">56.5MB</p><p class="text-idt25" data-id="1189">25帧/秒</p><p class="text-idt25" data-id="1190">10分钟</p><p class="text-idt25" data-id="1191">50</p><p class="text-idt25" data-id="1192">Dataset2</p><p class="text-idt25" data-id="1193">512.6MB</p><p class="text-idt25" data-id="1194">25帧/秒</p><p class="text-idt25" data-id="1195">63分钟</p><p class="text-idt25" data-id="1196">50</p><p class="text-idt25" data-id="1197">Dataset3</p><p class="text-idt25" data-id="1198">1GB</p><p class="text-idt25" data-id="1199">35帧/秒</p><p class="text-idt25" data-id="1200">92分钟</p><p class="text-idt25" data-id="1201">85</p><p class="text-idt25" data-id="1202">Dataset4</p><p class="text-idt25" data-id="1203">1.5GB</p><p class="text-idt25" data-id="1204">35帧/秒</p><p class="text-idt25" data-id="1205">101分钟</p><p class="text-idt25" data-id="1206">100</p><p class="text-idt25" data-id="1207">我们同只考虑代码行数划分微服务的方法（LOC）进行对比。当用户发送服务请求时，微服务平台管理模块会将请求转发给微服务划分模块，微服务模块执行相应的算法将服务划分为相应的微服务并且在服务注册组件中注册。为了避免平台中其他不稳定因素对实验结果的影响，我们保证实验条件不变的情况下，将该实验在相同实验环境下执行了10次并将10次的结果的平均值作为实验结果的最终值。</p><p class="text-idt25" data-id="1208">图5-1DSCS和LOC算法的缩减率对比图</p><p class="text-idt25" data-id="1209">虽然在面向对象设计领域有明确已有的质量标准，但是评估微服务质量标准的研究还是很少。因此，本文使用自定义的标准来衡量算法的效果。我们使用代码缩减率（csr）和服务复用率（drr）评估算法的效果。以下是代码缩减率（csr）和服务复用率的计算公式：</p><p class="text-idt25" data-id="1210">csr</p><p class="text-idt25" data-id="1211">𝑀</p><p class="text-idt25" data-id="1212">=</p><p class="text-idt25" data-id="1213">𝑐𝑜𝑑𝑒𝑠𝑖𝑧𝑒</p><p class="text-idt25" data-id="1214">𝑀</p><p class="text-idt25" data-id="1215">− 𝑐𝑜𝑑𝑒𝑠𝑖𝑧𝑒</p><p class="text-idt25" data-id="1216">𝑆</p><p class="text-idt25" data-id="1217">𝑀</p><p class="text-idt25" data-id="1218">𝑐𝑜𝑑𝑒𝑠𝑖𝑧𝑒</p><p class="text-idt25" data-id="1219">𝑀</p><p class="text-idt25" data-id="1220">其中M代表当前的单体架构平台中的服务，</p><p class="text-idt25" data-id="1221">𝑆</p><p class="text-idt25" data-id="1222">𝑀</p><p class="text-idt25" data-id="1223">代表单体架构平台中服务M划分之后的服务，codesize</p><p class="text-idt25" data-id="1224">.</p><p class="text-idt25" data-id="1225">表示服务的代码大小</p><p class="text-idt25" data-id="1226">drr</p><p class="text-idt25" data-id="1227">𝑠</p><p class="text-idt25" data-id="1228">=</p><p class="text-idt25" data-id="1229">𝑛𝑢𝑚</p><p class="text-idt25" data-id="1230">𝑎𝑝𝑝</p><p class="text-idt25" data-id="1231">−1</p><p class="text-idt25" data-id="1232">∗100%</p><p class="text-idt25" data-id="1233">其中num</p><p class="text-idt25" data-id="1234">𝑎𝑝𝑝</p><p class="text-idt25" data-id="1235">代表使用该服务s的应用的个数。</p><p class="text-idt25" data-id="1236">实验结果如图5-1所示。图中的横坐标代表不同的视频数据集合，纵坐标表示每一个数据集合对应的代码缩减率。可以看到，本文提出的微服务划分算法的代码缩减率是高于LOC算法的代码缩减率。</p><p class="text-idt25" data-id="1237">第二组实验中我们同样选取了相同的数据集，但是每一组数据的应用类型不同，第一组数据中同时执行两个应用，第二组数据中同时执行3个应用，第三组数据中同时执行5个应用，第四组数据中同时执行10个应用。我们同LOC算法进行了对比。同样为了避免其他不稳定因素影响，我们保证其他条件不变和实验环境不变，运行了10次并将10次计算结果的平均值作为每种服务划分算法下服务复用率的最终值。实验结果如图5-2所示。</p><p class="text-idt25" data-id="1238">图5-2DSCS和LOC算法的服务复用率对比图</p><p class="text-idt25" data-id="1239">图中横坐标表示不同的数据集，纵坐标表示每种数据集下的服务复用率。可以看出，本文提出的DSCS算法可以有效提高服务复用率。</p><p class="text-idt25" data-id="1240">5.3.3性能预测模型准确性验证试验</p><p class="text-idt25" data-id="1241">为了验证性能预测模型的准确性，本文选择了的数据集包括1000个监控视频文件，该视频文件有不同的分辨率，不同的文件大小，这些视频数据大约是10 GB。我们将数据集分成两部分，第一部分包括700个视频文件，用于训练数据处理时间模型，第二部分包括300个视频文件，用于模型测试。目标跟踪服务包括9个子任务，每一个子任务对应一个微服务，每一个微服务由相应的微服务实例提供服务。子任务分别为Data reading、Gray-scale processing、Gaussian blurring、Inter-frame difference processing、Contour extraction、SIFT feature extraction、feature matching、Tracking window drawing、Data writing。我们通过第四章提出的数据处理时间模型来预测每个微服务的数据处理时间，并且比较预测结果和通过离线处理的实际执行的值。为了最小化我们微服务平台的不稳定性地影响，每一个子任务执行了10次，做准确性比较时，我们取每个子任务的平均处理时间。最后我们使用准确率和均方差（MSE）来评估我们数据处理时间模型的准确性。</p><p class="text-idt25" data-id="1242">均方差（MSE）的计算公式如下： MSE</p><p class="text-idt25" data-id="1243">𝜃</p><p class="text-idt25" data-id="1244">=E</p><p class="text-idt25" data-id="1245">𝜃</p><p class="text-idt25" data-id="1246">−𝜃</p><p class="text-idt25" data-id="1247">2</p><p class="text-idt25" data-id="1248">其中</p><p class="text-idt25" data-id="1249">𝜃</p><p class="text-idt25" data-id="1250">是每个子任务的预测时间，θ是每个子任务的实际执行时间，E</p><p class="text-idt25" data-id="1251">.</p><p class="text-idt25" data-id="1252">是求均值操作。结果如表2所示。</p><p class="text-idt25" data-id="1253">表5-3 准确率和均方差比较</p><p class="text-idt25" data-id="1254">子任务名称</p><p class="text-idt25" data-id="1255">准确率</p><p class="text-idt25" data-id="1256">均方差（MSE）</p><p class="text-idt25" data-id="1257">Gray-scale processing</p><p class="text-idt25" data-id="1258">97.04%</p><p class="text-idt25" data-id="1259">0.0125</p><p class="text-idt25" data-id="1260">Gaussian blurring</p><p class="text-idt25" data-id="1261">96.43%</p><p class="text-idt25" data-id="1262">0.0067</p><p class="text-idt25" data-id="1263">Inter-frame difference processing</p><p class="text-idt25" data-id="1264">96.23%</p><p class="text-idt25" data-id="1265">0.0023</p><p class="text-idt25" data-id="1266">Contour extraction</p><p class="text-idt25" data-id="1267">96.10%</p><p class="text-idt25" data-id="1268">0.0196</p><p class="text-idt25" data-id="1269">SIFT feature extraction</p><p class="text-idt25" data-id="1270">93.73%</p><p class="text-idt25" data-id="1271">0.3211</p><p class="text-idt25" data-id="1272">Feature matching</p><p class="text-idt25" data-id="1273">97.16%</p><p class="text-idt25" data-id="1274">0.0460</p><p class="text-idt25" data-id="1275">Tracking window drawing</p><p class="text-idt25" data-id="1276">96.73%</p><p class="text-idt25" data-id="1277">0.0034</p><p class="text-idt25" data-id="1278">如表2中准确率和均方差的比较，子任务数据处理时间的平均的准确率是96%，除了子任务 SIFT feature extraction的准确率是93.73%，每一个均方差（ MSE）的值为都是在可接受范围内。因此可以得出我们的性能预测模型中的数据处理时间模型能够十分精确的预测微服务实例所需的数据处理时间。</p><p class="text-idt25" data-id="1279">5.3.4 服务路径选择算法效果验证试验</p><p class="text-idt25" data-id="1280">基于上一节验证的性能预测模型，本节我们将验证本文提出的性能感知的服务路径选择策略（ PSPAS）的效果，我们和默认的最优的服务路径选择策略（ OPTIMAL），最短路径选择策略（ SPS），以及动态服务路径选择策略（ DSPS）进行对比。最优的服务路径选择策略是通过离线任务执行而得到的最优的路径，在线执行时该方法不能用到；最短路径选择策略只是使用维特比算法得到微服务选择路径而没有考虑每一个微服务实例的处理能力动态改变；动态服务路径选择策略能够根据当微服务实例的当前状态来在线更新最优微服务路径，但是使用的时间预测模型中的特征值是历史性能记录。</p><p class="text-idt25" data-id="1281">为了验证本文提出的性能感知的服务路径选择策略（ PSPAS）与 OPTIMAL的性能最接近，且比 SPS， DSPS性能更优，我们首先设置影响因子微服务实例的个数为变量因素，当微服务实例的个数增加时，来观察四种服务路径选择策略的任务执行时间。</p><p class="text-idt25" data-id="1282">在验证过程中，本文使用1GB的视频数据集作为实验输入数据。目标跟踪服务包括9个子任务，每个子任务由相应的微服务类提供服务。首先，我们让每一个子任务的微服务实例的个数在[10，40]中随机选择，任务执行过程中，我们控制微服务实例的资源状态改变在10%之内（保持轻微改变）。之后，我们通过四种服务路径选择策略执行目标跟踪任务。为了避免其他不稳定因素对实验的影响，我们保证实验在相同的实验环境下运行10次，并将10次任务执行时间的平均值作为最后结果。我们保证其他条件不变，改变每一个微服务类的个数，微服务类的区间设置在[41，70][71，100][101，130]，[131，160]和[161，190]范围内，对于每一个微服务类区间，和[10，40]区间执行相同的操作，最后记录实验数据。实验结果如图5-1所示：</p><p class="text-idt25" data-id="1283">图5-3 当微服务资源轻微抖动时执行时间变化图</p><p class="text-idt25" data-id="1284">从图5-3中我们可以看出我们的方法PSPAS的执行效率和OPTIMAL的执行效率是最接近的。然而SPS方法的执行时间远远大于PSPAS，这是因为SPS策略只考虑了初始化的最优服务路径而没有考虑到在线任务执行过程中最优服务路径的改变。尽管DSPS能够冬天的更新服务路径，但是DSPS策略的执行效率是最差的。这说明性能预测模型的准确率对于最优微服务路径选择有很大影响。从图中我们可以得出，随着微服务实例个数的增加，每一种策略的执行时间是在减少，所以微服务路径选择策略具有良好的可扩展性。</p><p class="text-idt25" data-id="1285">为了和上一组实验做对比，本次验证中我们保证实验中的其他条件不变，只改变任务执行过程中，微服务实例资源状态抖动的剧烈程度，本组实验我们控制微服务实例资源抖动在30%~60%之间。实验结果如图5-4所示：</p><p class="text-idt25" data-id="1286">图中横坐标代表微服务实例个数所在的区间，纵坐标表示整个任务的执行时间，单位为分钟。</p><p class="text-idt25" data-id="1287">图5-4当微服务资源剧烈抖动时执行时间变化图</p><p class="text-idt25" data-id="1288">从图5-4中可以得出，和图5-3比较，可以看出 PSPAS策略与 OPTIMAL策略的性能曲线之间有了轻微变化，这是因为微服务平台动态的特性会降低 PSPAS的执行效率。同样的，由于在动态环境中，静态的微服务路径选择策略会受到严重影响，所以SPS策略的性能也降低了。然而我们的PSPAS策略仍然优于SPS策略和DSPS策略。</p><p class="text-idt25" data-id="1289">为了验证PSPAS算法的有效性，我们验证了应用中子任务的个数对微服务路径选择算法性能的影响。实验中，我们使用了目标跟踪中子任务构建了不同的视频服务，每一个视频服务的子任务个数不同。我们设置每一类服务的实例个数为90。同样的，每一个视频服务执行了10次并且将执行时间的平均值作为实验结果。实验结果如图5-3所示：</p><p class="text-idt25" data-id="1290">图中横坐标代表不同的视频任务，每个任务有不同的子任务数，纵坐标表示整个视频任务执行的时间，单位为分钟。</p><p class="text-idt25" data-id="1291">从图5-5可以看出，随着子任务个数的增加，每一个微服务路径选择策略的执行时间都会增加。明显的，我们的 PSPAS策略和 OPTIMAL策略的性能最接近并且优于其他两个服务路径选择策略，而且随着子任务个数的增加 PSPAS策略与 SPS策略和 DSPS策略之间的时间差也逐渐增加，所以当执行大型微服务应用时，我们的服务路径选择策略的性能是最优的。</p><p class="text-idt25" data-id="1292">图5-5 子任务个数改变时执行时间变化图</p><p class="text-idt25" data-id="1293">5.4 本章小结</p><p class="text-idt25" data-id="1294">本章首先详细介绍了平台的软硬件的配置环境，以及平台中的微服务划分模块和服务路径选择模块的具体实现，然后介绍了视频浓缩服务镜像和目标追踪服务镜像的具体实现，之后对平台的基本功能做了基本验证，最后通过实验验证了本文提出的微服务划分策略、服务路径选择策略的有效性以及性能预测模型的准确性，实验表明我们提出的微服务划分策略能够有效提升平台中服务的服用率减少代码的冗余，基于性能预测模型的服务路径选择策略，相比于其他服务路径选择策略，可以有效提高服务执行效率，降低服务执行时间。</p><p class="text-idt25" data-id="1295">第六章总结与展望</p><p class="text-idt25" data-id="1296">6.1总结</p><p class="text-idt25" data-id="1297">随着业务系统的扩张和业务需求的不断变更，业务系统的功能逐渐复杂，规模逐渐庞大，架构模式较为单一的应用架构已经不能满足业务的需求，因此微服务架构成为今年来解决以上需求的主流方案。然而目前对于微服务架构，业界尚无明确定义，而且围绕微服务的工作是有限的。如何划分微服务，制定划分策略，满足微服务内部的高内聚性和微服务之间的低耦合性，是我们面临的主要问题。对于基于微服务架构的分布式处理平台，微服务划分完成，如何组合微服务实例，制定相应的微服务路径选择策略，对于提高应用的执行效率尤其重要，也是目前研究的热点问题。围绕这两个目标，本文主要研究内容有以下四个部分：</p><p class="text-idt25" data-id="1298">（1）基于领域驱动设计思想的语义耦合的微服务划分策略</p><p class="text-idt25" data-id="1299">传统的服务划分方法中并没有根据平台需求以及平台中应用之间功能的相关性来综合考虑，这将导致服务划分后的结果是服务之间的耦合性比较差，代码复用率比较低，平台中代码的冗余度比较高。为了提高代码的复用率，我们提出了语义耦合的服务划分策略，该策略通过分析代码之间的语义耦合程度，来表示两个代码的耦合程度，将耦合度作为权重构建无向有权图，再通过社区发现算法 GN算法来找到最好的划分结果。通过实验验证了该方法可以将应用有效划分成微服务，并且能够提高服务的复用率，减少平台的代码量。</p><p class="text-idt25" data-id="1300">（2）微服务实例性能预测模型</p><p class="text-idt25" data-id="1301">本文通过分析当前主流的服务选择算法，发现当前的服务选择算法只考虑静态的 Qos特征，例如响应性、可用性、和吞吐量，并没有考虑选择的服务实例运行时的特征，而且也没有考虑任务本身的特征，因此本文提出了一种基于机器学习的时间预测模型，该模型包括数据执行时间模型和数据传输时间模型，数据执行时间模型结合微服务实例运行时特征以及数据本身的特征，例如 CPU利用率、内存利用率、数据分辨率、帧率等，数据传输时间模型结合了微服务实例之间的传输条件，例如数据大小、网络带宽，在基于大量训练数据的基础上，通过学习得到微服务实例的时间预测模型。</p><p class="text-idt25" data-id="1302">（3）性能感知的微服务路径选择策略</p><p class="text-idt25" data-id="1303">传统的微服务路径选择策略并没有同时考虑微服务实例运行时特征以及任务的特征。本文基于所提出的微服务性能预测模型，研究并实现了一种性能感知的服务路径选择策略PSPAS。该策略包括两个阶段：第一个阶段是初始化微服务路径，在此阶段本文使用最短路径算法构建最佳微服务路径；第二个阶段是微服务路径动态自适应更新阶段，在应用执行过程中基于路径搜索空间缩减原则动态更新最短路径，该策略提高了微服务应用的处理效率。</p><p class="text-idt25" data-id="1304">（4）基于微服务技术的验证平台</p><p class="text-idt25" data-id="1305">传统的分布式处理云平台系统采用的是单体架构，系统规模会随着业务量的进一步增加而急剧地膨胀，进而产生架构臃肿、业务逻辑复杂、数据流向复杂等一系列问题。这些问题会给整个系统的开发、维护、部署以及后期的升级带来巨大的困难。微服务架构成为近年来云计算领域的热门技术。本文采用微服务技术构建分布式云平台，并按照本文设计的基于领域驱动设计思想的语义耦合的微服务划分策略和性能感知的服务路径选择策略（ PSPAS）扩展实现了相关功能模块。最后通过视频浓缩服务验证了平台高效的任务处理效率。</p><p class="text-idt25" data-id="1306">6.2 展望</p><p class="text-idt25" data-id="1307">本文首先通过分析传统的微服务划分思想以及微服务划分策略的不足，结合微服务的设计原则以及平台的应用特性，提出了基于领域驱动设计思想的语义耦合的微服务划分算法，其次分析传统服务路径选择策略的不足，结合微服务实例的运行时特征以及微服务任务的特征，提出了性能感知的服务路径选择策略，最后通过视频浓缩服务对所述的微服务划分策略进行验证，可有效提高代码的复用率，以及减少平台代码冗余率；通过复杂的微服务应用对所述的服务选择策略进行验证，可有效提高平台的执行效率，具有一定的实用性。但是本文工作还存在一些可以进一步研究的方向：</p><p class="text-idt25" data-id="1308">（1）微服务实例性能预测模型。目前的微服务实例性能预测模型中的数据执行时间模型是使用机器学习中线性回归的方法来训练得到的，数据传输时间模型是直接使用公式计算得到。对于现在非线性机器学习模型，数据越多，模型改进越多，训练越准确。本文未来考虑使用更多或者更高质量的数据来优化数据执行时间模型，进一步提高模型的准确性。</p><p class="text-idt25" data-id="1309">（2）探索不同应用下微服务平台性能优化问题。本文主要关注基于微服务架构的分布式处理云平台的性能优化问题。本文提出的微服务划分策略结合了微服务划分原则以及我们微服务平台中应用的特征，然而我们需要研究更多类型的微服务平台的微服务划分问题，并进一步实现更通用的微服务平台的服务划分策略。</p><p class="text-idt25" data-id="1310">（3）更丰富的微服务应用。本文主要通过九个子任务的应用来验证微服务平台中提出的性能感知的服务路径选择算法的有效性，后期应该选择更大型的应用，远远超过9个子任务的微服务应用来优化算法。</p><p class="text-idt25" data-id="1311">参考文献</p><p class="text-idt25" data-id="1312">[1] Fowler M. Microservices: a definition of this new architectural term [EB/OL]. http://martinfowler.com/articles/micro-services.html，2014.</p><p class="text-idt25" data-id="1313">[2] Thones J. Microservices [J]. IEEE Software， 2015， 32(1): 116–116.</p><p class="text-idt25" data-id="1314">[3] Mazlami G， Cito J， Leitner P. Extraction of Microservices from Monolithic Software Architectures [C]. // International Conference on Web Services， IEEE， 2017: 524-531.</p><p class="text-idt25" data-id="1315">[5] Marcus A， Maletic J I. Identification of high-level concept clones in source code [C].// Annual International Conference on Automated Software Engineering， IEEE， 2001: 107-114.</p><p class="text-idt25" data-id="1316">[6] Poshyvanyk D， Marcus A. The conceptual coupling metrics for object-oriented systems [J]. ICSM， 2006， 6: 469–478.</p><p class="text-idt25" data-id="1317">[4] Newman S. Building Microservices [M]. O’Reilly Media， 2015.</p><p class="text-idt25" data-id="1318">[7] Alrifai M， Skoutas D， Risse T. Selecting Skyline Services for QoS-based Web Service Composition [C]. // WWW， ACM， 2010: 11-20.</p><p class="text-idt25" data-id="1319">[8] Deng S G， Wu H Y， Hu D， et al. Service Selection for Composition with QoS Correlations [C]. // IEEE Transactions on Service Computing， IEEE， 2016: 291-303.</p><p class="text-idt25" data-id="1320">[9] Saleem M S， Ding C， Liu X M， et al. Personalized Decision Making for QoS-based Service Selection [C]. // IEE International Conference on Web Services， IEEE， 2014: 17-24.</p><p class="text-idt25" data-id="1321">[10] Tan T H， Chen M， Liu Y， et al. Automated Runtime Recovery for QoS-based Service Composition [C]. // WWW， ACM， 2014: 563-574.</p><p class="text-idt25" data-id="1322">[11] Wang H， Wu Q， Chen X， et al. Adaptive and Dynamic Scervice Composition via Multiagent Reinforcement Learning [C]. // IEEE International Conference on Web Services， IEEE， 2014: 447-454.</p><p class="text-idt25" data-id="1323">[12] Peng S， Wang H， Yu Q. Estimation of Distribution with Restricted Boltzmann Machine for Adaptive Service Composition [C]. // IEEE International Conference on Web Services， IEEE， 2017: 114-121.</p><p class="text-idt25" data-id="1324">[13] Gysel M， Kolbener L， Giersche W. Service cutter: A systematic approach to service decomposition [C]. // European Conference on Service-Oriented and Cloud Computing， Springer， 2016. 185–200.</p><p class="text-idt25" data-id="1325">[14] Eberhard Wolff. What Are Microservices [M]. 2017.</p><p class="text-idt25" data-id="1326">[15] Mohsen A， Amjad I. Requirements Reconciliation forScalable and Secure Microservice(De)composition [C]. // IEEE 24th InternationalRequirements Engineering Conference Workshop， IEEE， 2016: 230-242.</p><p class="text-idt25" data-id="1327">[16]AsikT. Policy Enforcement upon Software Based on MicroserviceArchitecture [C]. // IEEE computer society， IEEE， 2017， pp: 283–287.</p><p class="text-idt25" data-id="1328">[17] Schermann G， Cito J， Leitner P. All the services large and micro: Revisiting industrial practice in services computing [C]. // International Conference on Service-Oriented Computing， IEEE， 2015. 36–47.</p><p class="text-idt25" data-id="1329">[18] Villamizar M， Garces O， Ochoa L et al. Infrastructure Cost Comparison of Running WebApplications in the Cloud Using AWS Lambda and Monolithic and Microservice Architectures[ C].//201616 th IEEE/ ACM International Symposium on Cluster， Cloud， and Grid Computing， IEEE/ ACM，2016: 179–182.</p><p class="text-idt25" data-id="1330">[19] KalexU. Business Capability Management: Your Key to the Business BoardRoom [M].</p><p class="text-idt25" data-id="1331">[20] PengS，Wang H，Yu Q. Estimation of Distribution with Restricted Boltzmann Machine for Adaptive Service Composition [C]. // IEEE International Conference on Web Services， IEEE， 2017: 114-121.</p><p class="text-idt25" data-id="1332">[21] Li H， Wu Z. Research on distributed architecture based on SOA[C]. // International Conference on Communication Software and Networks， IEEE，2009:670-674.</p><p class="text-idt25" data-id="1333">[22] Zhang Y Y， Jiao J X. An associative classification-based recommendation system for personalization in B2C e-commerce applications [C]. // Expert Systems With Applications， IEEE， 2006: 33.</p><p class="text-idt25" data-id="1334">[23] Strasser T， Rooker M， Ebenhofer G， et al. Multi-domain model-driven design of industrial automation and control systems [C]. // IEEE International Conference on Emerging Technologies and Factory Automation， IEEE， 2008: 1067-1071.</p><p class="text-idt25" data-id="1335">[24] Jive J. Jdon Framework [EB/OL]. http://www.jdon.com/jdonframework/.</p><p class="text-idt25" data-id="1336">[25] Goldston R L， Son J Y. Similarity [J]. Psychological Review， 2004: 254-278.</p><p class="text-idt25" data-id="1337">[26] Li M， Chen X， Xin M L， et al. The Simility Metric [J]. IEEE Transactions on Information Theory， 2003: 863-872.</p><p class="text-idt25" data-id="1338">[27] 邱明. 语义相似性度量及其在设计管理系统中的应用 [D]. 浙江大学， 2006.</p><p class="text-idt25" data-id="1339">[28] Osgood C E. The nature and measurement of meaning [J]. Psychological Bulletin， 1952: 197-237.</p><p class="text-idt25" data-id="1340">[29] Lee MD. Algorithms for Representing Similarity Data [M]. 1999.</p><p class="text-idt25" data-id="1341">[30] Landauer T K， Dumais S T C. Solution to Plato’s Problem: The Latent Semantic Analysis Theory of Acquisition， Induction and Representation of Knowledge [J].Psychological Review， 1997.</p><p class="text-idt25" data-id="1342">[31] Tversky A. Features of Similarity [J]. Psychological Review， 1977: 327-352.</p><p class="text-idt25" data-id="1343">[32] Santini S， Jain R. Similarity Measures [J]. IEEE Transactions on Pattern Analysis and Machine Intelligence， 1999: 871-883.</p><p class="text-idt25" data-id="1344">[33] Liu Y， Yang Y. Semantic Web Service Discovery Based on Text Clustering and Concept Similarity [J]. Computer Science， 2013: 211-214.</p><p class="text-idt25" data-id="1345">[34] Cheng Z H， Huang Z. Optimization of GN algorithm based on DNA computation [C]. // IEEE International Conference on Computer and Communications， IEEE， 2016: 1303-1308.</p><p class="text-idt25" data-id="1346">[35] Matsuba H， Joshi K， Hiltunen M， et al.Airfoil: A Topology Aware Distributed Load Balancing Service [C]. IEEE Cloud， IEEE， 2015: 325-332.</p><p class="text-idt25" data-id="1347">[36] Bailey S E， Godbole S S， Knutson C D. A Decade of Conway’s Law: A Literature Review from 2003-2012 [C]. // International Workshop on Replication in Empirical Software Engineering Research， IEEE， 2013: 1-14.</p><p class="text-idt25" data-id="1348">[37] Lee K， Yoon H， Park S. A Service Path Selection and Adaptation Algorithm in Service-Oriented Network Virtualization Architecture [C]. IEEE ICPADS， IEEE， 2013: 516-521.</p><p class="text-idt25" data-id="1349">[38] Canfora G， M.D.P， Esposito R， et al. An Approach for QoS aware Service Composition based on Genetic Algorithm [C]. // GECCO， 2005.</p><p class="text-idt25" data-id="1350">[39] Canfora G， et al. Service Composition (re)Binding driven by Application-specific QoS [C]. // Internation Conference on Service Oriented Computing， IEEE， 2006: 141-152.</p><p class="text-idt25" data-id="1351">[40] Zeng L Z， Benatallah B， Ngu A H H， et al. QoS-Aware Middleware for Web Services Composition [J]. // IEEE Transaction on Software Engineering， IEEE， 2004: 311-327.</p><p class="text-idt25" data-id="1352">[41] Yu T， Lin K J. Service Selection Algorithm for Web Services with End-to-end QoS Constraints [C]. // IEEE International Conference on E-Commerce Technology， IEEE， 2004: 129-136.</p><p class="text-idt25" data-id="1353">[42] Pistore M， Marconi A， Bertoli P. Automated Composition of Web Service by Planning at the Knowledge Level [C]. // IJCAI， IEEE， 2005: 1252-1259.</p><p class="text-idt25" data-id="1354">[43] Doshi P， Goodwin R， Akkiraju R， et al. Dynamic Workflow Composition Using Markov Decision Processes [C]. // International Journal of Web Services Research， IEEE， 2005: 1-17.</p><p class="text-idt25" data-id="1355">[44] Gao A Q， Yang D Q， Tang S W， et al. Web Service Composition Using Markov Decision Processes [C]. // Internation Conference on Web-Age Information Management， IEEE， 2005: 308-319.</p><p class="text-idt25" data-id="1356">[45] Gysel M， Kolbener L， Giersche W. Service Cutter: A Systematic Approach to Service Decomposition [C]. // International Federation for Information Processing， IEEE， 2016: 185-200.</p><p class="text-idt25" data-id="1357">[46] Tatsubori M， Takahashi K. Decomposition and Abstraction of Web Applications for Web Service Extraction and Composition [C]. // IEEE International Conference on Web Services， IEEE， 2006: 859-868.</p><p class="text-idt25" data-id="1358">[47] Jiang B， Ye L Y， Wang J L， et al. A Semantic-based Approach to Service Clustering from Service Documents [C]. // IEEE International Conference on Services Computing， IEEE， 2017: 265-272.</p><p class="text-idt25" data-id="1359">[48] Joselyne M I， Mukasa D， Kanagwa B， et al. Partitioning Microservices: A Domain Engineering Approach [C]. // IEEE Symposium on Software Engineering in Africa， IEEE， 2018: 43-49.</p><p class="text-idt25" data-id="1360">[49] Wang J， Zhang N， Zeng C， et al. Towards Services Discovery based on Service Goal Extraction and Recommendation [C]. // IEEE International Conference on Services Computing， IEEE， 2013: 65-72.</p><p class="text-idt25" data-id="1361">[50] Erradi A， Tosic V， Maheshwari P. MASC - .NET-Based Middleware for Adaptive Composite Web Services [C]. // IEEE International Conference on Web Services， IEEE， 2007: 727-734.</p><p class="text-idt25" data-id="1362">[51] Mohr F， Jungmann A， Bvning H K. Automated Online Service Composition [C]. // IEEE International Conference on Services Computing， IEEE， 2015: 57-64.</p><p class="text-idt25" data-id="1363">[52] Narayanan S， McIlraith S， Simulation， verification and automated composition of web services [C]. // WWW， ACM， 2002: 77-88.</p><p class="text-idt25" data-id="1364">[53] Hossain M S， Moniruzzaman M， Muhammad G， et al. Big data-driven service composition using parallel clustered particle swarm optimization in mobile environment [J]. IEEE Transaction Services Computing， 2016， 9(5): 806-817.</p><p class="text-idt25" data-id="1365">[54] Tan T H， Chen M， Andre E， et al. Automated runtime recovery for qos-based service composition [C]. // WWW， ACM， 2014: 563-574.</p><p class="text-idt25" data-id="1366">[55] Wang H， Wu Q， Chen X， et al. Adaptive and dynamic service composition via multiagent reinforcement learning [C]. // IEEE International Conference on Web Services， IEEE， 2014: 447-454.</p><p class="text-idt25" data-id="1367">[56] Peng S， Wang H， Yu Q. Estimation of Distribution with Restricted Boltzmann Machine for Adaptive Service Composition [C]. // IEEE International Conference on Web Services， IEEE， 2017: 114-121.</p><p class="text-idt25" data-id="1368">[57] Saleem M S， Ding C， Liu X， et al. Personalized Decision Making for QoS-based Service Selection [C]. // IEEE International Conference on Web Services， IEEE， 2014: 17-24.</p><p class="text-idt25" data-id="1369">[58] Schaeﬀer S E. Graph clustering [J]. Computer Science Review 1.1， 2007: 27-64.</p><p class="text-idt25" data-id="1370">[59] Kruchten P B. The 4+ 1 view model of architecture [C]. // IEEE Software， IEEE， 1995: 42–50.</p><p class="text-idt25" data-id="1371">致谢</p><p class="text-idt25" data-id="1372">时光荏苒，三年的研究生生涯即将结束。2016年9月，我幸运的考上了北京邮电大学，与计算机学院智能通信软件与多媒体北京市重点实验室结下了难得的缘分，在大学期间一直憧憬进入北京邮电大学继续进修计算机科学与技术专业，为了实现自己心中美好的愿望，用自己不懈的努力，披荆斩棘，成功的得到老师的青睐，由此开始了我内心憧憬的研究生学习生活，并且在科研、学习、生活中我都成长了许多。这三年的研究生生活，使我从一个稚嫩、浮躁的大学生慢慢成长为一个踏实、努力、上进、敢于追求目标、更加严谨的硕士研究生。这一切都受到了我身边的老师、同学、朋友的影响。在此，我要真诚的感谢指导过我的每一位恩师，帮助过我的每一位学姐学长，耐心倾听我的同窗朋友，积极鼓励我的家人。</p><p class="text-idt25" data-id="1373">感谢我的导师张海涛老师对我的培养。感谢您在我的学习和生活给予的无微不至的关怀和帮助。您在工作中的一丝不苟、安排有序的做事风格深深的激励我并且鼓励我，让我内心又多了一份动力，您在科研上严谨的逻辑思维，更是让我受益匪浅。</p><p class="text-idt25" data-id="1374">感谢实验室的同窗好友。感谢高阳阳学长和朱彦沛学姐对我工作上和学习上的指导，你们对待科研的严谨态度、对每一个细节的认真处理的做事风格、努力踏实积极阳光的生活态度成为我为人处理的榜样；感谢唐炳昌同学对我在学习上的帮助，作为同学，我深深敬佩你在在学习上积极，努力，踏实的态度以及独到的思考，和你共同学习的实验室时光，将成为我受益一生的财富；感谢徐政钧学弟、耿欣学妹和实验室其他同学们，我们一起学习，一起团建，相互帮助，在最好的年华能够遇到你们，让我学习到了很多。</p><p class="text-idt25" data-id="1375">感谢我的家人。是爸爸妈妈对生活踏实的态度，鼓励我在每次困难面前不畏惧，勇往直前，是爸爸妈妈每一次的鼓励，让我的心态再次乐观起来，给予我无限动力，是爸爸妈妈背后默默无闻的支持，成为我坚强的后盾，让我踏实前行。</p><p class="text-idt25" data-id="1376">最后，我要感谢各位评审老师们和专家们在百忙之中抽出宝贵的时间审阅我的文章，谢谢你们的宝贵意见和建议。</p><p class="text-idt25" data-id="1377">作者攻读学位期间发表的学术论文目录</p><p class="text-idt25" data-id="1378">[1] Haitao Zhang，Ning Yang， Zhengjun Xu， Bingchang Tang， Huadong Ma. Microservice Based Video Cloud Platform with Performance-aware Service Path Selection. //2018 IEEE 10th International Conference Web Service (IEEE ICWS 2018)， San Francisco， USA， 2018.</p>        <div class="paper-footer">
            <p>检测报告由<a href="http://www.paperpass.com/" target="_black">PaperPass</a>文献相似度检测系统生成</p>
            <p>Copyright © 2007-2019 PaperPass</p>
        </div>
    </div>

</div>
</body>
<script type="text/javascript" src="js/jquery.min.js"></script>
<script type="text/javascript" src="js/Lib.js"></script>
<script type="text/javascript">
    Report.report_id = '5c7b97268b0fbdik4';
</script>
<script type="text/javascript">
    (function(System,$){
        var cache = new System.Cache(System.report_id,localStorage);
        $(function(){
            $.each(cache.get(),function(){
                $('[data-id='+this.id+']').addClass('g-font-color green').html(this.text);
            });

        });
    })(Report,jQuery);

</script>
</html>
